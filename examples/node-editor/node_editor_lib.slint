// Node Editor Library
//
// This library provides a composite NodeEditor component that wraps the native
// NodeEditorBackground and NodeEditorOverlay items into a convenient three-layer
// architecture with unified properties and callbacks.
//
// Usage:
// ```slint
// import { NodeEditor, Link, Pin, PinTypes, PinId } from "node_editor_lib.slint";
//
// MainWindow {
//     NodeEditor {
//         pan-x: 0px;
//         pan-y: 0px;
//         zoom: 1.0;
//
//         link-requested => { /* validate and create link */ }
//
//         // Add nodes
//         for node in nodes: MyNode { ... }
//
//         // Add links
//         for link in links: Link { path-commands: ...; }
//     }
// }
// ```

/// Standard pin types for library components.
/// Applications can extend these by defining their own globals.
export global PinTypes {
    /// Input pin type (standard for data/signal inputs)
    out property <int> input: 1;
    /// Output pin type (standard for data/signal outputs)
    out property <int> output: 2;
}

/// Pin ID encoding and decoding utilities.
/// Pin IDs encode both the node ID and pin type using the formula:
/// pin_id = node_id * 10 + pin_type
export global PinId {
    /// Create a pin ID from node ID and pin type
    /// Example: PinId.make(5, PinTypes.input) => 51
    pure public function make(node-id: int, pin-type: int) -> int {
        return node-id * 10 + pin-type;
    }

    /// Extract node ID from a pin ID
    /// Example: PinId.get-node-id(51) => 5
    pure public function get-node-id(pin-id: int) -> int {
        return pin-id / 10;
    }

    /// Extract pin type from a pin ID
    /// Example: PinId.get-type(51) => 1
    pure public function get-type(pin-id: int) -> int {
        return mod(pin-id, 10);
    }

    /// Check if a pin is an output type
    pure public function is-output(pin-id: int) -> bool {
        return mod(pin-id, 10) == PinTypes.output;
    }

    /// Check if a pin is an input type (not output)
    pure public function is-input(pin-id: int) -> bool {
        return mod(pin-id, 10) != PinTypes.output;
    }

    /// Check if two pins are compatible for linking.
    /// Compatible means: one output + one input from different nodes.
    pure public function are-compatible(start-pin: int, end-pin: int) -> bool {
        if start-pin == end-pin { return false; }
        if self.get-node-id(start-pin) == self.get-node-id(end-pin) { return false; }
        return self.is-output(start-pin) != self.is-output(end-pin);
    }
}

/// A bezier link between two pins using core-generated SVG path commands.
export component Link inherits Path {
    /// SVG path commands from core's bezier calculation
    /// Format: "M x0 y0 C x1 y1 x2 y2 x3 y3"
    in property <string> path-commands;
    /// Color of the link
    in property <color> link-color: #888888;
    /// Line width (will be scaled by zoom if provided)
    in property <length> line-width: 2px;

    width: 100%;
    height: 100%;
    stroke: link-color;
    stroke-width: line-width;
    fill: transparent;

    // Set viewbox to match actual size so SVG coordinates map 1:1
    viewbox-x: 0;
    viewbox-y: 0;
    viewbox-width: max(self.width / 1px, 1);
    viewbox-height: max(self.height / 1px, 1);

    commands: path-commands;
}

/// A connection point on a node where links can be attached.
///
/// The Pin component encapsulates rendering and drag-to-link interaction.
/// Pins are positioned within node components and report their center position
/// for link attachment. When dragged, they fire callbacks to create links.
///
/// Standard color schemes:
/// - Input pins (data): base #4CAF50 (green), hover #66BB6A
/// - Output pins: base #2196F3 (blue), hover #42A5F5
/// - Control/parameter inputs: base #FFC107 (yellow), hover #FFD54F
///
/// Example usage:
/// ```slint
/// Pin {
///     x: 8px * zoom;
///     y: 40px * zoom;
///     pin-id: PinId.make(node-id, PinTypes.input);
///     zoom: zoom;
///     base-color: #4CAF50;
///     hover-color: #66BB6A;
///     base-size: 12px;
///     drag-started(id, x, y) => { /* handle drag start */ }
///     drag-moved(id, x, y) => { /* handle drag move */ }
///     drag-ended(id, x, y) => { /* handle drag end */ }
/// }
/// ```
export component Pin inherits Rectangle {
    /// Unique identifier for this pin (use PinId.make(node-id, pin-type))
    in property <int> pin-id;
    /// Current zoom level for scaling
    in property <float> zoom: 1.0;
    /// Base color when not hovered
    in property <color> base-color;
    /// Color when hovered
    in property <color> hover-color;
    /// Base size before zoom scaling
    in property <length> base-size: 12px;

    // Computed properties
    property <length> pin-size: base-size * zoom;
    property <length> pin-radius: pin-size / 2;

    /// Center X position in parent coordinates (for link attachment)
    out property <length> center-x: self.x + pin-radius;
    /// Center Y position in parent coordinates (for link attachment)
    out property <length> center-y: self.y + pin-radius;

    /// Fired when drag starts (pin-id, x, y in parent coordinates)
    callback drag-started(int, length, length);
    /// Fired during drag (pin-id, x, y in parent coordinates)
    callback drag-moved(int, length, length);
    /// Fired when drag ends (pin-id, x, y in parent coordinates)
    callback drag-ended(int, length, length);

    // Rectangle styling
    width: pin-size;
    height: pin-size;
    background: touch.has-hover ? hover-color : base-color;
    border-radius: pin-radius;

    // Drag interaction
    touch := TouchArea {
        property <bool> drag-active: false;

        pointer-event(event) => {
            if event.kind == PointerEventKind.down && event.button == PointerEventButton.left {
                drag-active = true;
                root.drag-started(pin-id, center-x, center-y);
            }
            if event.kind == PointerEventKind.up && drag-active {
                drag-active = false;
                // Calculate cursor position in parent coordinates
                root.drag-ended(pin-id, center-x + self.mouse-x - pin-radius, center-y + self.mouse-y - pin-radius);
            }
        }
        moved => {
            if drag-active {
                // Update link preview with cursor position
                root.drag-moved(pin-id, center-x + self.mouse-x - pin-radius, center-y + self.mouse-y - pin-radius);
            }
        }
    }
}

/// Composite node editor with three-layer architecture.
///
/// Provides:
/// - Layer 1: Grid background (automatically rendered)
/// - Layer 2: User children (nodes, links via @children)
/// - Layer 3: Input overlay (pan, zoom, selection, link creation)
/// - Selection box and link preview (automatically rendered on top)
export component NodeEditor {
    // === Shared viewport state ===
    /// Current pan offset X
    in-out property <length> pan-x;
    /// Current pan offset Y
    in-out property <length> pan-y;
    /// Current zoom level
    in-out property <float> zoom: 1.0;

    // === Grid properties ===
    /// Spacing between grid lines
    in property <length> grid-spacing: 24px;
    /// Enable grid snapping for node positions
    in property <bool> grid-snapping: true;
    /// Color of grid lines
    in property <color> grid-color: #404040;
    /// Background color of the canvas
    in property <brush> background-color: #1a1a1a;

    // === Zoom constraints ===
    /// Minimum zoom level
    in property <float> min-zoom: 0.1;
    /// Maximum zoom level
    in property <float> max-zoom: 3.0;

    // === Node drag state (set during node drag for link position updates) ===
    /// Whether nodes are currently being dragged
    in property <bool> is-dragging: false;
    /// X offset of dragged nodes
    in property <length> drag-offset-x;
    /// Y offset of dragged nodes
    in property <length> drag-offset-y;

    // === Output: Grid ===
    /// Generated SVG path commands for grid lines
    out property <string> grid-commands: background-layer.grid-commands;

    // === Output: Selection box state ===
    /// Whether box selection is active
    out property <bool> is-selecting: overlay.is-selecting;
    /// Selection box X
    out property <length> selection-x: overlay.selection-x;
    /// Selection box Y
    out property <length> selection-y: overlay.selection-y;
    /// Selection box width
    out property <length> selection-width: overlay.selection-width;
    /// Selection box height
    out property <length> selection-height: overlay.selection-height;

    // === Output: Context menu ===
    /// Context menu X coordinate
    out property <length> context-menu-x: overlay.context-menu-x;
    /// Context menu Y coordinate
    out property <length> context-menu-y: overlay.context-menu-y;

    // === Output: Link creation state ===
    /// Whether a link is being created
    out property <bool> is-creating-link: overlay.is-creating-link;
    /// Link start X
    out property <length> link-start-x: overlay.link-start-x;
    /// Link start Y
    out property <length> link-start-y: overlay.link-start-y;
    /// Link end X (bidirectional for drag updates)
    in-out property <length> link-end-x <=> overlay.link-end-x;
    /// Link end Y
    in-out property <length> link-end-y <=> overlay.link-end-y;
    /// Starting pin ID
    out property <int> link-start-pin-id: overlay.link-start-pin-id;
    /// Core-generated bezier path for link preview
    out property <string> link-preview-path-commands: overlay.link-preview-path-commands;

    // === Input: Link creation triggers ===
    /// Pin ID to start link from (set before calling start-link)
    in property <int> pending-link-pin-id <=> overlay.pending-link-pin-id;
    /// X position to start link from
    in property <length> pending-link-x <=> overlay.pending-link-x;
    /// Y position to start link from
    in property <length> pending-link-y <=> overlay.pending-link-y;
    /// Set to true to complete link creation
    in property <bool> complete-link-creation <=> overlay.complete-link-creation;
    /// Target pin ID for completion
    in property <int> target-pin-id <=> overlay.target-pin-id;

    // === Input: Pin position reporting ===
    in property <int> reporting-pin-id <=> overlay.reporting-pin-id;
    in property <length> reporting-pin-x <=> overlay.reporting-pin-x;
    in property <length> reporting-pin-y <=> overlay.reporting-pin-y;
    in property <length> pin-hit-radius <=> overlay.pin-hit-radius;
    // NOTE: Pin positions need to go to BOTH Background (for link rendering) AND Overlay (for pin hit-testing)
    in-out property <string> pending-pins-batch;

    // Forward pin batch to both layers
    changed pending-pins-batch => {
        background-layer.pending-pins-batch = pending-pins-batch;
        overlay.pending-pins-batch = pending-pins-batch;
    }

    // === Output: Link request result ===
    /// Requested link start pin ID (read from link-requested callback)
    out property <int> requested-link-start-pin: overlay.requested-link-start-pin;
    /// Requested link end pin ID (read from link-requested callback)
    out property <int> requested-link-end-pin: overlay.requested-link-end-pin;

    // === Input: Node rectangle reporting ===
    in property <int> reporting-node-id <=> overlay.reporting-node-id;
    in property <length> reporting-node-x <=> overlay.reporting-node-x;
    in property <length> reporting-node-y <=> overlay.reporting-node-y;
    in property <length> reporting-node-width <=> overlay.reporting-node-width;
    in property <length> reporting-node-height <=> overlay.reporting-node-height;
    // NOTE: Node rects need to go to BOTH Background (for link rendering) AND Overlay (for box selection & pin hit-testing)
    in-out property <string> pending-node-rects-batch;

    // Forward node rect batch to both layers
    changed pending-node-rects-batch => {
        background-layer.pending-node-rects-batch = pending-node-rects-batch;
        overlay.pending-node-rects-batch = pending-node-rects-batch;
    }

    // === Input: Link reporting (NOW BOUND TO BACKGROUND LAYER) ===
    in property <int> reporting-link-id <=> background-layer.reporting-link-id;
    in property <int> reporting-link-start-pin-id <=> background-layer.reporting-link-start-pin-id;
    in property <int> reporting-link-end-pin-id <=> background-layer.reporting-link-end-pin-id;
    in property <color> reporting-link-color <=> background-layer.reporting-link-color;
    in-out property <string> pending-links-batch <=> background-layer.pending-links-batch;
    in-out property <string> pending-deleted-link-ids <=> background-layer.pending-deleted-link-ids;

    // === Output: Link position data (FROM BACKGROUND LAYER) ===
    // NOTE: link-positions-data removed - legacy format no longer generated
    /// Core-generated bezier paths for all links
    in-out property <string> link-bezier-paths <=> background-layer.link-bezier-paths;

    // === Output: Selection state ===
    /// Selected node IDs from box selection (comma-separated)
    out property <string> selected-node-ids-str: overlay.selected-node-ids-str;
    /// Currently selected node IDs
    out property <string> current-selected-ids: overlay.current-selected-ids;
    /// Currently selected link IDs
    out property <string> current-selected-link-ids: overlay.current-selected-link-ids;

    // === Input: Node click handling ===
    in property <int> clicked-node-id <=> overlay.clicked-node-id;
    in property <bool> clicked-shift-held <=> overlay.clicked-shift-held;

    // === Output: Link hover state ===
    out property <int> hovered-link-id: overlay.hovered-link-id;
    in property <length> link-hover-distance <=> overlay.link-hover-distance;

    // === Output: Debug ===
    out property <int> debug-pin-count: overlay.debug-pin-count;
    // NOTE: debug-link-count removed - links are now in Background

    // === Callbacks: Triggers (set properties first, then call) ===
    callback start-link <=> overlay.start-link;
    callback pin-position-changed <=> overlay.pin-position-changed;
    callback node-rect-changed <=> overlay.node-rect-changed;
    callback link-reported <=> background-layer.link-reported;
    callback node-clicked <=> overlay.node-clicked;

    // === Callbacks: Events ===
    callback link-requested <=> overlay.link-requested;
    callback link-hovered <=> overlay.link-hovered;
    callback link-selection-changed <=> overlay.link-selection-changed;
    callback link-positions-changed <=> background-layer.link-positions-changed;
    callback link-cancelled <=> overlay.link-cancelled;
    callback context-menu-requested <=> overlay.context-menu-requested;
    callback selection-changed <=> overlay.selection-changed;
    callback viewport-changed <=> overlay.viewport-changed;
    callback delete-selected <=> overlay.delete-selected;
    callback add-node-requested <=> overlay.add-node-requested;

    /// Node drag ended - delta is automatically snapped if grid-snapping is enabled
    /// Applications should connect node drag-ended callbacks to this
    callback node-drag-ended(/* delta-x */ float, /* delta-y */ float);

    // === Helper Functions ===
    /// Snaps a coordinate value to the nearest grid position
    /// Uses the grid-spacing property automatically
    pure public function snap-to-grid(value: float) -> float {
        if (root.grid-spacing > 0px) {
            return round(value / (root.grid-spacing / 1px)) * (root.grid-spacing / 1px);
        }
        return value;
    }

    /// Call this from node drag-ended handlers - applies snapping and fires node-drag-ended callback
    /// Applications should wire: drag-ended(id, dx, dy) => { editor.handle-node-drag(dx, dy); }
    public function handle-node-drag(delta-x: length, delta-y: length) {
        // Apply snapping if enabled, then fire callback
        root.node-drag-ended(
            root.grid-snapping ? root.snap-to-grid(delta-x / 1px) : delta-x / 1px,
            root.grid-snapping ? root.snap-to-grid(delta-y / 1px) : delta-y / 1px
        );
    }

    // === Layer 1: Background ===
    background-layer := NodeEditorBackground {
        width: 100%;
        height: 100%;
        grid-spacing: root.grid-spacing;
        grid-color: root.grid-color;
        background-color: root.background-color;
        pan-x <=> root.pan-x;
        pan-y <=> root.pan-y;
        zoom: root.zoom;

        // Background fill
        Rectangle {
            width: 100%;
            height: 100%;
            background: root.background-color;
        }

        // Grid
        Path {
            width: 100%;
            height: 100%;
            stroke: root.grid-color;
            stroke-width: 1px;
            fill: transparent;
            viewbox-x: 0;
            viewbox-y: 0;
            viewbox-width: max(self.width / 1px, 1);
            viewbox-height: max(self.height / 1px, 1);
            commands: background-layer.grid-commands;
        }
    }

    // === Layer 2: User children (nodes, links) ===
    @children

    // === Layer 3: Overlay ===
    overlay := NodeEditorOverlay {
        width: 100%;
        height: 100%;
        pan-x <=> root.pan-x;
        pan-y <=> root.pan-y;
        zoom <=> root.zoom;
        min-zoom: root.min-zoom;
        max-zoom: root.max-zoom;
        is-dragging: root.is-dragging;
        drag-offset-x: root.drag-offset-x;
        drag-offset-y: root.drag-offset-y;

        // Wire link query to Background
        changed query-link-at-x => {
            background-layer.query-link-at-x = overlay.query-link-at-x;
            background-layer.query-link-at-y = overlay.query-link-at-y;
            background-layer.link-hover-distance = overlay.link-hover-distance;
            background-layer.handle-link-query();
            overlay.link-at-result = background-layer.link-at-result;
        }
        changed query-link-at-y => {
            background-layer.query-link-at-x = overlay.query-link-at-x;
            background-layer.query-link-at-y = overlay.query-link-at-y;
            background-layer.link-hover-distance = overlay.link-hover-distance;
            background-layer.handle-link-query();
            overlay.link-at-result = background-layer.link-at-result;
        }
    }

    // === Selection box (on top) ===
    Rectangle {
        visible: overlay.is-selecting;
        x: overlay.selection-x;
        y: overlay.selection-y;
        width: overlay.selection-width;
        height: overlay.selection-height;
        background: #4488ff20;
        border-color: #4488ff;
        border-width: 1px;
    }

    // === Link preview (on top) ===
    Path {
        visible: overlay.is-creating-link;
        width: 100%;
        height: 100%;
        commands: overlay.link-preview-path-commands;
        stroke: #ffffff80;
        stroke-width: 2px * root.zoom;
        fill: transparent;
        viewbox-x: 0;
        viewbox-y: 0;
        viewbox-width: max(self.width / 1px, 1);
        viewbox-height: max(self.height / 1px, 1);
    }
}
