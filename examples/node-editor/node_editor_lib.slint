// Node Editor Library
//
// This library provides a composite NodeEditor component that wraps the native
// NodeEditorBackground and NodeEditorOverlay items into a convenient three-layer
// architecture with unified properties and callbacks.
//
// Usage:
// ```slint
// import { NodeEditor, Link, Pin, PinTypes, PinId } from "node_editor_lib.slint";
//
// MainWindow {
//     NodeEditor {
//         pan-x: 0px;
//         pan-y: 0px;
//         zoom: 1.0;
//
//         link-requested => { /* validate and create link */ }
//
//         // Add nodes
//         for node in nodes: MyNode { ... }
//
//         // Add links
//         for link in links: Link { path-commands: ...; }
//     }
// }
// ```

/// Standard pin types for library components.
/// Applications can extend these by defining their own globals.
export global PinTypes {
    /// Input pin type (standard for data/signal inputs)
    out property <int> input: 1;
    /// Output pin type (standard for data/signal outputs)
    out property <int> output: 2;
}

/// Pin ID encoding and decoding utilities.
/// Pin IDs encode both the node ID and pin type using the formula:
/// pin_id = node_id * 10 + pin_type
export global PinId {
    /// Create a pin ID from node ID and pin type
    /// Example: PinId.make(5, PinTypes.input) => 51
    pure public function make(node-id: int, pin-type: int) -> int {
        return node-id * 10 + pin-type;
    }

    /// Extract node ID from a pin ID
    /// Example: PinId.get-node-id(51) => 5
    pure public function get-node-id(pin-id: int) -> int {
        return pin-id / 10;
    }

    /// Extract pin type from a pin ID
    /// Example: PinId.get-type(51) => 1
    pure public function get-type(pin-id: int) -> int {
        return mod(pin-id, 10);
    }

    /// Check if a pin is an output type
    pure public function is-output(pin-id: int) -> bool {
        return mod(pin-id, 10) == PinTypes.output;
    }

    /// Check if a pin is an input type (not output)
    pure public function is-input(pin-id: int) -> bool {
        return mod(pin-id, 10) != PinTypes.output;
    }
}

/// Simplified node representation for minimap rendering.
/// Contains only the essential positioning and identification data.
export struct MinimapNode {
    /// Unique node identifier
    id: int,
    /// X position in graph coordinates
    x: length,
    /// Y position in graph coordinates
    y: length,
    /// Node width
    width: length,
    /// Node height
    height: length,
    /// Optional per-node color for minimap rendering
    color: color,
}

/// Positioning options for minimap placement within the NodeEditor.
export enum MinimapPosition {
    /// Top-left corner
    top-left,
    /// Top-right corner
    top-right,
    /// Bottom-left corner
    bottom-left,
    /// Bottom-right corner
    bottom-right,
}

/// Minimap component for bird's-eye view of the node graph.
///
/// Displays a scaled-down overview of all nodes and the current viewport.
/// Coordinates are automatically transformed from graph space to minimap space.
///
/// Example usage:
/// ```slint
/// Minimap {
///     nodes: minimap-nodes;
///     viewport-x: editor.pan-x;
///     viewport-y: editor.pan-y;
///     viewport-zoom: editor.zoom;
///     viewport-width: editor.width;
///     viewport-height: editor.height;
///     graph-min-x: 0px;
///     graph-min-y: 0px;
///     graph-max-x: 2000px;
///     graph-max-y: 1500px;
/// }
/// ```
export component Minimap inherits Rectangle {
    // === Data Input ===
    /// Node rectangles (simplified)
    in property <[MinimapNode]> nodes;

    // === Viewport State ===
    /// Current pan offset X (from NodeEditor)
    in property <length> viewport-x;
    /// Current pan offset Y (from NodeEditor)
    in property <length> viewport-y;
    /// Current zoom level (from NodeEditor)
    in property <float> viewport-zoom: 1.0;
    /// Canvas width (from NodeEditor)
    in property <length> viewport-width;
    /// Canvas height (from NodeEditor)
    in property <length> viewport-height;

    // === Graph Bounds ===
    /// Minimum X coordinate of the graph
    in property <length> graph-min-x;
    /// Minimum Y coordinate of the graph
    in property <length> graph-min-y;
    /// Maximum X coordinate of the graph
    in property <length> graph-max-x;
    /// Maximum Y coordinate of the graph
    in property <length> graph-max-y;

    // === Styling ===
    /// Minimap width
    in property <length> minimap-width: 200px;
    /// Minimap height
    in property <length> minimap-height: 150px;
    /// Background color (semi-transparent)
    in property <color> minimap-background-color: #1a1a1aee;
    /// Node color
    in property <color> minimap-node-color: #4a4a4a;
    /// Viewport border color
    in property <color> minimap-viewport-border-color: #ffffff;
    /// Viewport border width
    in property <length> minimap-viewport-border-width: 2px;
    /// Border color
    in property <color> minimap-border-color: #333333;
    /// Border width
    in property <length> minimap-border-width: 1px;
    /// Internal padding
    in property <length> minimap-padding: 8px;

    // === Interaction ===
    /// Callback fired when user clicks minimap to navigate
    /// Parameters: graph-x, graph-y (center position to navigate to)
    callback navigate-to(/* graph-x */ length, /* graph-y */ length);

    // === Coordinate Transformation ===
    /// Graph width (computed)
    property <length> graph-width: max(root.graph-max-x - root.graph-min-x, 1px);
    /// Graph height (computed)
    property <length> graph-height: max(root.graph-max-y - root.graph-min-y, 1px);

    /// Available minimap rendering area width
    property <length> available-width: root.minimap-width - 2 * root.minimap-padding;
    /// Available minimap rendering area height
    property <length> available-height: root.minimap-height - 2 * root.minimap-padding;

    /// Scale factor to fit graph into minimap
    property <float> scale: min(
        root.available-width / root.graph-width,
        root.available-height / root.graph-height
    );

    // === Viewport in Graph Coordinates ===
    /// Visible area minimum X in graph coordinates
    property <length> visible-min-x: -root.viewport-x / root.viewport-zoom;
    /// Visible area minimum Y in graph coordinates
    property <length> visible-min-y: -root.viewport-y / root.viewport-zoom;
    /// Visible area maximum X in graph coordinates
    property <length> visible-max-x: root.visible-min-x + (root.viewport-width / root.viewport-zoom);
    /// Visible area maximum Y in graph coordinates
    property <length> visible-max-y: root.visible-min-y + (root.viewport-height / root.viewport-zoom);

    // === Viewport Indicator in Minimap Coordinates ===
    property <length> viewport-indicator-x: root.minimap-padding + (root.visible-min-x - root.graph-min-x) * root.scale;
    property <length> viewport-indicator-y: root.minimap-padding + (root.visible-min-y - root.graph-min-y) * root.scale;
    property <length> viewport-indicator-width: (root.visible-max-x - root.visible-min-x) * root.scale;
    property <length> viewport-indicator-height: (root.visible-max-y - root.visible-min-y) * root.scale;

    // === Minimap Container ===
    width: root.minimap-width;
    height: root.minimap-height;
    background: root.minimap-background-color;
    border-color: root.minimap-border-color;
    border-width: root.minimap-border-width;
    border-radius: 4px;

    // === Node Rectangles ===
    for node in root.nodes: Rectangle {
        // Transform graph coordinates to minimap coordinates
        x: root.minimap-padding + (node.x - root.graph-min-x) * root.scale;
        y: root.minimap-padding + (node.y - root.graph-min-y) * root.scale;
        width: node.width * root.scale;
        height: node.height * root.scale;

        // Use per-node color if set, otherwise default
        background: node.color.alpha > 0 ? node.color : root.minimap-node-color;
    }

    // === Viewport Indicator ===
    Rectangle {
        x: root.viewport-indicator-x;
        y: root.viewport-indicator-y;
        width: root.viewport-indicator-width;
        height: root.viewport-indicator-height;

        // Transparent fill, visible border only
        background: transparent;
        border-color: root.minimap-viewport-border-color;
        border-width: root.minimap-viewport-border-width;
    }

    // === Click-to-Navigate Interaction ===
    TouchArea {
        width: 100%;
        height: 100%;
        mouse-cursor: MouseCursor.pointer;

        clicked => {
            // Convert minimap coordinates to graph coordinates
            // Step 1: Remove padding offset
            // Step 2: Convert from minimap scale to graph scale
            // Step 3: Add graph offset
            root.navigate-to(
                root.graph-min-x + ((self.mouse-x - root.minimap-padding) / root.scale),
                root.graph-min-y + ((self.mouse-y - root.minimap-padding) / root.scale)
            );
        }
    }
}

/// A bezier link between two pins using core-generated SVG path commands.
export component Link inherits Path {
    /// SVG path commands from core's bezier calculation
    /// Format: "M x0 y0 C x1 y1 x2 y2 x3 y3"
    in property <string> path-commands;
    /// Color of the link
    in property <color> link-color: #888888;
    /// Line width (will be scaled by zoom if provided)
    in property <length> line-width: 2px;

    width: 100%;
    height: 100%;
    stroke: link-color;
    stroke-width: line-width;
    fill: transparent;

    // Set viewbox to match actual size so SVG coordinates map 1:1
    viewbox-x: 0;
    viewbox-y: 0;
    viewbox-width: max(self.width / 1px, 1);
    viewbox-height: max(self.height / 1px, 1);

    commands: path-commands;
}

/// Base component for all node types in the node editor.
///
/// BaseNode provides the core functionality needed by all nodes:
/// - Transform properties (world position, zoom, pan, drag offset)
/// - Drag handling with threshold detection and absolute positioning
/// - Selection state and visual feedback
/// - Callbacks for node and pin interactions
/// - Automatic rectangle reporting for hit-testing
///
/// Subclasses should:
/// - Set width and height based on their content
/// - Add node-specific content (title, pins, widgets, etc.)
/// - Optionally add custom callbacks for widget interactions
///
/// Example usage:
/// ```slint
/// export component MyNode inherits BaseNode {
///     width: 150px * zoom;
///     height: 80px * zoom;
///
///     // Add custom content
///     Rectangle { /* title bar */ }
///     Pin { /* pins */ }
/// }
/// ```
export component BaseNode inherits Rectangle {
    // === Common Properties ===

    /// Unique identifier for this node
    in property <int> node-id;

    /// Whether this node is currently selected
    in property <bool> selected: false;

    /// World position (grid space) - base position from model
    in property <length> world-x;
    in property <length> world-y;

    /// Transform parameters (from parent NodeEditor)
    in property <float> zoom: 1.0;
    in property <length> pan-x: 0px;
    in property <length> pan-y: 0px;

    /// External drag offset (for multi-select: all selected nodes get same offset)
    in property <length> drag-offset-x: 0px;
    in property <length> drag-offset-y: 0px;

    // === Common Callbacks ===

    /// Called when a pin drag starts (pin-id, screen-x, screen-y)
    callback pin-drag-started(int, length, length);

    /// Called when a pin drag moves (pin-id, screen-x, screen-y)
    callback pin-drag-moved(int, length, length);

    /// Called when a pin drag ends (pin-id, screen-x, screen-y)
    callback pin-drag-ended(int, length, length);

    /// Called when node is clicked (node-id, shift-held)
    callback clicked(int, bool);

    /// Called when node drag starts (node-id, already-selected)
    callback drag-started(int, bool);

    /// Called when node drag moves (node-id, offset-x, offset-y)
    callback drag-moved(int, length, length);

    /// Called when node drag ends (node-id, delta-x, delta-y)
    callback drag-ended(int, length, length);

    /// Called to report node rectangle for hit-testing (node-id, x, y, width, height)
    callback report-rect(int, length, length, length, length);

    // === Computed Properties ===

    /// Screen position calculated from world position + drag offset
    out property <length> screen-x: (world-x + drag-offset-x) * zoom + pan-x;
    out property <length> screen-y: (world-y + drag-offset-y) * zoom + pan-y;

    // === Common Styling ===

    x: screen-x;
    y: screen-y;
    background: selected ? #3a3a4a : #2d2d2d;
    border-radius: 8px * zoom;
    border-width: selected ? 2px * zoom : 1px * zoom;
    border-color: selected ? #4a9eff : #555;

    // === Common Handlers ===

    // Report rect on init
    init => {
        report-rect(node-id, screen-x, screen-y, self.width, self.height);
    }

    // Report rect whenever screen position changes (for link updates during drag)
    changed screen-x => {
        report-rect(node-id, screen-x, screen-y, self.width, self.height);
    }
    changed screen-y => {
        report-rect(node-id, screen-x, screen-y, self.width, self.height);
    }

    // === Drag Handling ===
    // Rendered first so node content appears on top and can intercept events

    TouchArea {
        property <bool> shift-held: false;
        property <bool> was-dragged: false;
        property <length> drag-threshold: 5px;

        // Store initial press position in absolute (window) coordinates
        // This is needed because the node moves during drag, which would change
        // the local coordinate system and cause oscillation
        property <length> press-abs-x: 0px;
        property <length> press-abs-y: 0px;

        // Current offset computed from absolute positions
        property <length> current-offset-x: self.absolute-position.x + self.mouse-x - press-abs-x;
        property <length> current-offset-y: self.absolute-position.y + self.mouse-y - press-abs-y;

        pointer-event(event) => {
            if event.kind == PointerEventKind.down && event.button == PointerEventButton.left {
                shift-held = event.modifiers.shift;
                was-dragged = false;
                // Store absolute position of press
                press-abs-x = self.absolute-position.x + self.pressed-x;
                press-abs-y = self.absolute-position.y + self.pressed-y;
            }
            if event.kind == PointerEventKind.up && event.button == PointerEventButton.left {
                if !was-dragged {
                    root.clicked(node-id, shift-held);
                } else {
                    // Drag ended - report final delta using absolute coordinates
                    root.drag-ended(node-id, current-offset-x / zoom, current-offset-y / zoom);
                }
            }
        }

        moved => {
            if self.pressed {
                // Check threshold using absolute coordinate offsets
                if !was-dragged {
                    if current-offset-x > drag-threshold ||
                       (-current-offset-x) > drag-threshold ||
                       current-offset-y > drag-threshold ||
                       (-current-offset-y) > drag-threshold {
                        was-dragged = true;
                        root.drag-started(node-id, selected);
                    }
                }

                // Report offset to parent
                if was-dragged {
                    root.drag-moved(node-id, current-offset-x / zoom, current-offset-y / zoom);
                }
            }
        }
    }

    // Subclasses add their content here (rendered on top of TouchArea)
    // Content should include: title, pins, widgets, etc.
}

/// A connection point on a node where links can be attached.
///
/// The Pin component encapsulates rendering and drag-to-link interaction.
/// Pins are positioned within node components and report their center position
/// for link attachment. When dragged, they fire callbacks to create links.
///
/// Standard color schemes:
/// - Input pins (data): base #4CAF50 (green), hover #66BB6A
/// - Output pins: base #2196F3 (blue), hover #42A5F5
/// - Control/parameter inputs: base #FFC107 (yellow), hover #FFD54F
///
/// Example usage:
/// ```slint
/// Pin {
///     x: 8px * zoom;
///     y: 40px * zoom;
///     pin-id: PinId.make(node-id, PinTypes.input);
///     zoom: zoom;
///     base-color: #4CAF50;
///     hover-color: #66BB6A;
///     base-size: 12px;
///     drag-started(id, x, y) => { /* handle drag start */ }
///     drag-moved(id, x, y) => { /* handle drag move */ }
///     drag-ended(id, x, y) => { /* handle drag end */ }
/// }
/// ```
export component Pin inherits Rectangle {
    /// Unique identifier for this pin (use PinId.make(node-id, pin-type))
    in property <int> pin-id;
    /// Current zoom level for scaling
    in property <float> zoom: 1.0;
    /// Base color when not hovered
    in property <color> base-color;
    /// Color when hovered
    in property <color> hover-color;
    /// Base size before zoom scaling
    in property <length> base-size: 12px;

    /// Parent node's screen X position (for coordinate offset calculation)
    in property <length> node-screen-x: 0px;
    /// Parent node's screen Y position (for coordinate offset calculation)
    in property <length> node-screen-y: 0px;

    // Computed properties
    property <length> pin-size: base-size * zoom;
    property <length> pin-radius: pin-size / 2;

    /// Center X position in parent coordinates (for link attachment)
    out property <length> center-x: self.x + pin-radius;
    /// Center Y position in parent coordinates (for link attachment)
    out property <length> center-y: self.y + pin-radius;

    /// Fired when drag starts (pin-id, screen-x, screen-y)
    /// Coordinates are already offset by node position
    callback drag-started(int, length, length);
    /// Fired during drag (pin-id, screen-x, screen-y)
    /// Coordinates are already offset by node position
    callback drag-moved(int, length, length);
    /// Fired when drag ends (pin-id, screen-x, screen-y)
    /// Coordinates are already offset by node position
    callback drag-ended(int, length, length);

    // Rectangle styling
    width: pin-size;
    height: pin-size;
    background: touch.has-hover ? hover-color : base-color;
    border-radius: pin-radius;

    // Drag interaction
    touch := TouchArea {
        property <bool> drag-active: false;

        pointer-event(event) => {
            if event.kind == PointerEventKind.down && event.button == PointerEventButton.left {
                drag-active = true;
                // Apply node screen position offset internally
                root.drag-started(pin-id, node-screen-x + center-x, node-screen-y + center-y);
            }
            if event.kind == PointerEventKind.up && drag-active {
                drag-active = false;
                // Calculate cursor position in screen coordinates
                root.drag-ended(pin-id,
                    node-screen-x + center-x + self.mouse-x - pin-radius,
                    node-screen-y + center-y + self.mouse-y - pin-radius);
            }
        }
        moved => {
            if drag-active {
                // Update link preview with cursor position in screen coordinates
                root.drag-moved(pin-id,
                    node-screen-x + center-x + self.mouse-x - pin-radius,
                    node-screen-y + center-y + self.mouse-y - pin-radius);
            }
        }
    }
}

/// Composite node editor with three-layer architecture.
///
/// Provides:
/// - Layer 1: Grid background (automatically rendered)
/// - Layer 2: User children (nodes, links via @children)
/// - Layer 3: Input overlay (pan, zoom, selection, link creation)
/// - Selection box and link preview (automatically rendered on top)
export component NodeEditor {
    // === Shared viewport state ===
    /// Current pan offset X
    in-out property <length> pan-x;
    /// Current pan offset Y
    in-out property <length> pan-y;
    /// Current zoom level
    in-out property <float> zoom: 1.0;

    // === Grid properties ===
    /// Spacing between grid lines
    in property <length> grid-spacing: 24px;
    /// Enable grid snapping for node positions
    in property <bool> grid-snapping: true;
    /// Color of grid lines
    in property <color> grid-color: #404040;
    /// Background color of the canvas
    in property <brush> background-color: #1a1a1a;

    // === Zoom constraints ===
    /// Minimum zoom level
    in property <float> min-zoom: 0.1;
    /// Maximum zoom level
    in property <float> max-zoom: 3.0;

    // === Minimap configuration ===
    /// Enable minimap rendering and interaction
    in property <bool> minimap-enabled: false;
    /// Position of the minimap within the editor
    in property <MinimapPosition> minimap-position: MinimapPosition.bottom-right;

    // === Minimap data ===
    /// Simplified node data for minimap rendering (populated by application)
    in property <[MinimapNode]> minimap-nodes: [];

    // === Graph bounds (set by application for minimap rendering) ===
    /// Minimum X coordinate of the graph (set by application or computed from nodes)
    in-out property <length> graph-min-x: 0px;
    /// Minimum Y coordinate of the graph (set by application or computed from nodes)
    in-out property <length> graph-min-y: 0px;
    /// Maximum X coordinate of the graph (set by application or computed from nodes)
    in-out property <length> graph-max-x: 1600px;
    /// Maximum Y coordinate of the graph (set by application or computed from nodes)
    in-out property <length> graph-max-y: 1200px;

    // === Node drag state (managed internally by NodeEditor) ===
    /// Whether nodes are currently being dragged (read-only for children)
    out property <bool> is-dragging: root.internal-is-dragging;
    /// X offset of dragged nodes (read-only for children)
    out property <length> drag-offset-x: root.internal-drag-offset-x;
    /// Y offset of dragged nodes (read-only for children)
    out property <length> drag-offset-y: root.internal-drag-offset-y;

    // Internal drag state (private)
    property <bool> internal-is-dragging: false;
    property <length> internal-drag-offset-x: 0px;
    property <length> internal-drag-offset-y: 0px;

    // === Output: Grid ===
    /// Generated SVG path commands for grid lines
    out property <string> grid-commands: background-layer.grid-commands;

    // === Output: Selection box state ===
    /// Whether box selection is active
    out property <bool> is-selecting: overlay.is-selecting;
    /// Selection box X
    out property <length> selection-x: overlay.selection-x;
    /// Selection box Y
    out property <length> selection-y: overlay.selection-y;
    /// Selection box width
    out property <length> selection-width: overlay.selection-width;
    /// Selection box height
    out property <length> selection-height: overlay.selection-height;

    // === Output: Context menu ===
    /// Context menu X coordinate
    out property <length> context-menu-x: overlay.context-menu-x;
    /// Context menu Y coordinate
    out property <length> context-menu-y: overlay.context-menu-y;

    // === Output: Link creation state ===
    /// Whether a link is being created
    out property <bool> is-creating-link: overlay.is-creating-link;
    /// Link start X
    out property <length> link-start-x: overlay.link-start-x;
    /// Link start Y
    out property <length> link-start-y: overlay.link-start-y;
    /// Link end X (bidirectional for drag updates)
    in-out property <length> link-end-x <=> overlay.link-end-x;
    /// Link end Y
    in-out property <length> link-end-y <=> overlay.link-end-y;
    /// Starting pin ID
    out property <int> link-start-pin-id: overlay.link-start-pin-id;
    /// Core-generated bezier path for link preview
    out property <string> link-preview-path-commands: overlay.link-preview-path-commands;

    // === Input: Link creation triggers ===
    /// Pin ID to start link from (set before calling start-link)
    in property <int> pending-link-pin-id <=> overlay.pending-link-pin-id;
    /// X position to start link from
    in property <length> pending-link-x <=> overlay.pending-link-x;
    /// Y position to start link from
    in property <length> pending-link-y <=> overlay.pending-link-y;
    /// Set to true to complete link creation
    in property <bool> complete-link-creation <=> overlay.complete-link-creation;
    /// Target pin ID for completion
    in property <int> target-pin-id <=> overlay.target-pin-id;

    // === Input: Pin position reporting ===
    in property <length> pin-hit-radius <=> overlay.pin-hit-radius;
    // NOTE: Pin positions need to go to BOTH Background (for link rendering) AND Overlay (for pin hit-testing)
    in-out property <string> pending-pins-batch;

    // Forward pin batch to both layers
    changed pending-pins-batch => {
        background-layer.pending-pins-batch = pending-pins-batch;
        overlay.pending-pins-batch = pending-pins-batch;
    }

    // === Output: Link request result ===
    /// Requested link start pin ID (read from link-requested callback)
    out property <int> requested-link-start-pin: overlay.requested-link-start-pin;
    /// Requested link end pin ID (read from link-requested callback)
    out property <int> requested-link-end-pin: overlay.requested-link-end-pin;

    // === Input: Node rectangle reporting ===
    in property <int> reporting-node-id <=> overlay.reporting-node-id;
    in property <length> reporting-node-x <=> overlay.reporting-node-x;
    in property <length> reporting-node-y <=> overlay.reporting-node-y;
    in property <length> reporting-node-width <=> overlay.reporting-node-width;
    in property <length> reporting-node-height <=> overlay.reporting-node-height;
    // NOTE: Node rects need to go to BOTH Background (for link rendering) AND Overlay (for box selection & pin hit-testing)
    in-out property <string> pending-node-rects-batch;

    // Forward node rect batch to both layers
    changed pending-node-rects-batch => {
        background-layer.pending-node-rects-batch = pending-node-rects-batch;
        overlay.pending-node-rects-batch = pending-node-rects-batch;
    }

    // === Input: Link reporting (NOW BOUND TO BACKGROUND LAYER) ===
    in property <int> reporting-link-id <=> background-layer.reporting-link-id;
    in property <int> reporting-link-start-pin-id <=> background-layer.reporting-link-start-pin-id;
    in property <int> reporting-link-end-pin-id <=> background-layer.reporting-link-end-pin-id;
    in property <color> reporting-link-color <=> background-layer.reporting-link-color;
    in-out property <string> pending-links-batch <=> background-layer.pending-links-batch;
    in-out property <string> pending-deleted-link-ids <=> background-layer.pending-deleted-link-ids;

    // === Output: Link position data (FROM BACKGROUND LAYER) ===
    // NOTE: link-positions-data removed - legacy format no longer generated
    /// Core-generated bezier paths for all links
    in-out property <string> link-bezier-paths <=> background-layer.link-bezier-paths;

    // === Output: Selection state ===
    /// Selected node IDs from box selection (comma-separated)
    out property <string> selected-node-ids-str: overlay.selected-node-ids-str;
    /// Currently selected node IDs
    out property <string> current-selected-ids: overlay.current-selected-ids;
    /// Currently selected link IDs
    out property <string> current-selected-link-ids: overlay.current-selected-link-ids;

    // === Input: Node click handling ===
    in-out property <int> clicked-node-id <=> overlay.clicked-node-id;
    in-out property <bool> clicked-shift-held <=> overlay.clicked-shift-held;

    // === Output: Link hover state ===
    out property <int> hovered-link-id: overlay.hovered-link-id;
    in property <length> link-hover-distance <=> overlay.link-hover-distance;

    // === Output: Debug ===
    out property <int> debug-pin-count: overlay.debug-pin-count;

    // === Callbacks: Triggers (set properties first, then call) ===
    callback start-link <=> overlay.start-link;
    callback link-reported <=> background-layer.link-reported;
    callback node-clicked <=> overlay.node-clicked;

    // === Callbacks: Events ===
    callback link-requested <=> overlay.link-requested;
    callback link-hovered <=> overlay.link-hovered;
    callback link-selection-changed <=> overlay.link-selection-changed;
    callback link-positions-changed <=> background-layer.link-positions-changed;
    callback link-cancelled <=> overlay.link-cancelled;
    callback context-menu-requested <=> overlay.context-menu-requested;
    callback selection-changed <=> overlay.selection-changed;
    callback viewport-changed <=> overlay.viewport-changed;
    callback delete-selected <=> overlay.delete-selected;
    callback add-node-requested <=> overlay.add-node-requested;

    /// Node drag ended - delta is automatically snapped if grid-snapping is enabled
    /// Applications should connect this to update their model
    callback node-drag-ended(/* delta-x */ float, /* delta-y */ float);

    // === Helper Functions ===
    /// Snaps a coordinate value to the nearest grid position
    /// Uses the grid-spacing property automatically
    pure public function snap-to-grid(value: float) -> float {
        if (root.grid-spacing > 0px) {
            return round(value / (root.grid-spacing / 1px)) * (root.grid-spacing / 1px);
        }
        return value;
    }

    /// Start node drag - call from node drag-started handler
    /// Handles selection updates and initializes drag state
    /// Applications should wire: drag-started(id, already-selected) => { editor.start-node-drag(id, already-selected); }
    public function start-node-drag(node-id: int, already-selected: bool) {
        // Only change selection if the node is not already selected
        // This preserves multi-selection when dragging a selected node
        if !already-selected {
            root.clicked-node-id = node-id;
            root.clicked-shift-held = false;
            root.selection-changed();  // Notify application of selection change
        }

        // Initialize drag state
        root.internal-is-dragging = true;
        root.internal-drag-offset-x = 0px;
        root.internal-drag-offset-y = 0px;
    }

    /// Update node drag - call from node drag-moved handler
    /// Applications should wire: drag-moved(id, offset-x, offset-y) => { editor.update-node-drag(offset-x, offset-y); }
    public function update-node-drag(offset-x: length, offset-y: length) {
        root.internal-drag-offset-x = offset-x;
        root.internal-drag-offset-y = offset-y;
    }

    /// End node drag - call from node drag-ended handler
    /// Applies snapping and fires node-drag-ended callback
    /// Applications should wire: drag-ended(id, delta-x, delta-y) => { editor.end-node-drag(delta-x, delta-y); }
    public function end-node-drag(delta-x: length, delta-y: length) {
        // Apply snapping if enabled, then fire callback
        root.node-drag-ended(
            root.grid-snapping ? root.snap-to-grid(delta-x / 1px) : delta-x / 1px,
            root.grid-snapping ? root.snap-to-grid(delta-y / 1px) : delta-y / 1px
        );

        // Reset drag state
        root.internal-is-dragging = false;
        root.internal-drag-offset-x = 0px;
        root.internal-drag-offset-y = 0px;
    }

    /// @deprecated Use start-node-drag, update-node-drag, and end-node-drag instead
    /// Call this from node drag-ended handlers - applies snapping and fires node-drag-ended callback
    public function handle-node-drag(delta-x: length, delta-y: length) {
        root.end-node-drag(delta-x, delta-y);
    }

    // === Minimap Positioning ===
    /// Minimap size (used for positioning calculations)
    property <length> minimap-size-width: 200px;
    property <length> minimap-size-height: 150px;
    /// Margin from edges
    property <length> minimap-margin: 16px;

    /// Compute minimap X position based on minimap-position
    pure function compute-minimap-x() -> length {
        if (root.minimap-position == MinimapPosition.top-left || root.minimap-position == MinimapPosition.bottom-left) {
            return root.minimap-margin;
        } else {
            return root.width - root.minimap-size-width - root.minimap-margin;
        }
    }

    /// Compute minimap Y position based on minimap-position
    pure function compute-minimap-y() -> length {
        if (root.minimap-position == MinimapPosition.top-left || root.minimap-position == MinimapPosition.top-right) {
            return root.minimap-margin;
        } else {
            return root.height - root.minimap-size-height - root.minimap-margin;
        }
    }

    // === Layer 1: Background ===
    background-layer := NodeEditorBackground {
        width: 100%;
        height: 100%;
        grid-spacing: root.grid-spacing;
        grid-color: root.grid-color;
        background-color: root.background-color;
        pan-x <=> root.pan-x;
        pan-y <=> root.pan-y;
        zoom: root.zoom;

        // Background fill
        Rectangle {
            width: 100%;
            height: 100%;
            background: root.background-color;
        }

        // Grid
        Path {
            width: 100%;
            height: 100%;
            stroke: root.grid-color;
            stroke-width: 1px;
            fill: transparent;
            viewbox-x: 0;
            viewbox-y: 0;
            viewbox-width: max(self.width / 1px, 1);
            viewbox-height: max(self.height / 1px, 1);
            commands: background-layer.grid-commands;
        }
    }

    // === Layer 2: User children (nodes, links) ===
    @children

    // === Layer 3: Overlay ===
    overlay := NodeEditorOverlay {
        width: 100%;
        height: 100%;
        pan-x <=> root.pan-x;
        pan-y <=> root.pan-y;
        zoom <=> root.zoom;
        min-zoom: root.min-zoom;
        max-zoom: root.max-zoom;
        is-dragging: root.is-dragging;
        drag-offset-x: root.drag-offset-x;
        drag-offset-y: root.drag-offset-y;

        // Wire link query to Background
        changed query-link-at-x => {
            background-layer.query-link-at-x = overlay.query-link-at-x;
            background-layer.query-link-at-y = overlay.query-link-at-y;
            background-layer.link-hover-distance = overlay.link-hover-distance;
            background-layer.handle-link-query();
            overlay.link-at-result = background-layer.link-at-result;
        }
        changed query-link-at-y => {
            background-layer.query-link-at-x = overlay.query-link-at-x;
            background-layer.query-link-at-y = overlay.query-link-at-y;
            background-layer.link-hover-distance = overlay.link-hover-distance;
            background-layer.handle-link-query();
            overlay.link-at-result = background-layer.link-at-result;
        }
    }

    // === Selection box (on top) ===
    Rectangle {
        visible: overlay.is-selecting;
        x: overlay.selection-x;
        y: overlay.selection-y;
        width: overlay.selection-width;
        height: overlay.selection-height;
        background: #4488ff20;
        border-color: #4488ff;
        border-width: 1px;
    }

    // === Link preview (on top) ===
    Path {
        visible: overlay.is-creating-link;
        width: 100%;
        height: 100%;
        commands: overlay.link-preview-path-commands;
        stroke: #ffffff80;
        stroke-width: 2px * root.zoom;
        fill: transparent;
        viewbox-x: 0;
        viewbox-y: 0;
        viewbox-width: max(self.width / 1px, 1);
        viewbox-height: max(self.height / 1px, 1);
    }

    // === Minimap (on top) ===
    if root.minimap-enabled: Minimap {
        x: root.compute-minimap-x();
        y: root.compute-minimap-y();

        // Data
        nodes: root.minimap-nodes;

        // Viewport state
        viewport-x: root.pan-x;
        viewport-y: root.pan-y;
        viewport-zoom: root.zoom;
        viewport-width: root.width;
        viewport-height: root.height;

        // Graph bounds
        graph-min-x: root.graph-min-x;
        graph-min-y: root.graph-min-y;
        graph-max-x: root.graph-max-x;
        graph-max-y: root.graph-max-y;

        // Size
        minimap-width: root.minimap-size-width;
        minimap-height: root.minimap-size-height;

        // Navigation callback - center clicked position in viewport
        navigate-to(graph-x, graph-y) => {
            root.pan-x = -graph-x * root.zoom + (root.width / 2);
            root.pan-y = -graph-y * root.zoom + (root.height / 2);
        }
    }
}
