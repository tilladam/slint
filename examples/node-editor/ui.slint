// Node Editor Example
//
// This example demonstrates the NodeEditor composite component which wraps
// NodeEditorBackground and NodeEditorOverlay into a convenient three-layer
// architecture.
//
// The composite handles:
// - Grid background rendering
// - Pan and zoom
// - Box selection
// - Link creation with bezier preview
// - Selection box rendering
//
// Usage pattern:
// 1. Add nodes as children of NodeEditor
// 2. Add links as children (using Link component)
// 3. Handle callbacks for link creation, selection changes, etc.

import { NodeEditor, Link } from "node_editor_lib.slint";

// Node layout constants - single source of truth
// These are exported so Rust can access them
export global NodeConstants {
    out property <length> node-base-width: 150px;
    out property <length> node-base-height: 80px;
    out property <length> pin-size: 12px;
    out property <length> pin-margin: 8px;
    out property <length> title-height: 24px;
}

export global FilterNodeConstants {
    out property <length> base-width: 260px;
    out property <length> base-height: 148px;  // 8 + 28 + 8 + 32*3 + 8
    out property <length> pin-size: 12px;
    out property <length> pin-margin: 4px;
    out property <length> content-padding: 8px;
    out property <length> title-height: 28px;
    out property <length> row-height: 32px;
}
import { FilterNode, FilterNodeData } from "filter_node.slint";

// Data structure for nodes - exported to Rust
// Note: Selection state is owned by core (overlay.current-selected-ids), not stored here
export struct NodeData {
    id: int,
    title: string,
    world-x: float,
    world-y: float,
}

// Data structure for links - exported to Rust
// Bezier path commands are computed by core and synced to Rust
export struct LinkData {
    id: int,
    start-pin-id: int,
    end-pin-id: int,
    color: color,
    // Core-generated bezier path command (set by Rust from core's output)
    // Format: "M x0 y0 C x1 y1 x2 y2 x3 y3"
    path-commands: string,
}

// Re-export FilterNodeData for Rust
export { FilterNodeData }


// A basic node component with interactive pins
component Node inherits Rectangle {
    in property <string> title: "Node";
    in property <int> node-id;
    in property <int> input-pin-id: node-id * 10 + 1;   // e.g., node 1 -> pin 11
    in property <int> output-pin-id: node-id * 10 + 2;  // e.g., node 1 -> pin 12

    // Selection state
    in property <bool> selected: false;

    // World coordinates (grid space) - base position from model
    in property <length> world-x;
    in property <length> world-y;

    // Transform parameters (from parent)
    in property <float> zoom: 1.0;
    in property <length> pan-x: 0px;
    in property <length> pan-y: 0px;

    // External drag offset (for multi-select: all selected nodes get same offset)
    in property <length> drag-offset-x: 0px;
    in property <length> drag-offset-y: 0px;

    // Callbacks for pin drag-to-link (pin-id, x, y)
    callback pin-drag-started(int, length, length);
    callback pin-drag-moved(int, length, length);
    callback pin-drag-ended(int, length, length);

    // Callback when node is clicked (for selection) - passes node-id and shift-held
    callback clicked(int, bool);

    // Callbacks for node dragging (for multi-select support)
    callback drag-started(int, bool);  // node-id, already-selected
    callback drag-moved(int, length, length);  // node-id, offset-x, offset-y
    callback drag-ended(int, length, length);  // node-id, delta-x, delta-y

    // Callback to report node rectangle (for overlay hit-testing and box selection)
    // Parameters: node-id, x, y, width, height (all in screen coordinates)
    callback report-rect(int, length, length, length, length);

    // Report rect on init
    init => {
        report-rect(node-id, screen-x, screen-y, self.width, self.height);
    }

    // Pin dimensions (scaled by zoom)
    property <length> pin-size: NodeConstants.pin-size * zoom;
    property <length> pin-radius: pin-size / 2;

    // Base dimensions (from global constants)
    property <length> base-width: NodeConstants.node-base-width;
    property <length> base-height: NodeConstants.node-base-height;

    // Screen position calculated from world position + drag offset
    property <length> screen-x: (world-x + drag-offset-x) * zoom + pan-x;
    property <length> screen-y: (world-y + drag-offset-y) * zoom + pan-y;

    // Expose pin positions (center of pin circles, in parent coordinates)
    out property <length> input-pin-x: screen-x + input-pin.x + pin-radius;
    out property <length> input-pin-y: screen-y + input-pin.y + pin-radius;
    out property <length> output-pin-x: screen-x + output-pin.x + pin-radius;
    out property <length> output-pin-y: screen-y + output-pin.y + pin-radius;

    x: screen-x;
    y: screen-y;
    width: base-width * zoom;
    height: base-height * zoom;
    background: selected ? #3a3a4a : #2d2d2d;
    border-radius: 8px * zoom;
    border-width: selected ? 2px * zoom : 1px * zoom;
    border-color: selected ? #4a9eff : #555;

    // Title bar
    Rectangle {
        x: 8px * zoom;
        y: 8px * zoom;
        width: parent.width - 16px * zoom;
        height: 24px * zoom;
        background: selected ? #4a6a9a : #3d3d3d;
        border-radius: 4px * zoom;

        Text {
            text: title;
            color: white;
            font-size: 14px * zoom;
            horizontal-alignment: center;
            vertical-alignment: center;
        }
    }

    // Drag handling for the node body (must be before pins so pins are on top)
    TouchArea {
        property <bool> shift-held: false;
        property <bool> was-dragged: false;
        property <length> drag-threshold: 5px;
        // Store initial press position in absolute (window) coordinates
        // This is needed because the node moves during drag, which would change
        // the local coordinate system and cause oscillation
        property <length> press-abs-x: 0px;
        property <length> press-abs-y: 0px;
        // Current offset computed from absolute positions
        property <length> current-offset-x: self.absolute-position.x + self.mouse-x - press-abs-x;
        property <length> current-offset-y: self.absolute-position.y + self.mouse-y - press-abs-y;

        pointer-event(event) => {
            if event.kind == PointerEventKind.down && event.button == PointerEventButton.left {
                shift-held = event.modifiers.shift;
                was-dragged = false;
                // Store absolute position of press
                press-abs-x = self.absolute-position.x + self.pressed-x;
                press-abs-y = self.absolute-position.y + self.pressed-y;
            }
            if event.kind == PointerEventKind.up && event.button == PointerEventButton.left {
                if !was-dragged {
                    root.clicked(node-id, shift-held);
                } else {
                    // Drag ended - report final delta using absolute coordinates
                    root.drag-ended(node-id, current-offset-x / zoom, current-offset-y / zoom);
                }
            }
        }
        moved => {
            if self.pressed {
                // Check threshold using absolute coordinate offsets
                if !was-dragged {
                    if current-offset-x > drag-threshold ||
                       (-current-offset-x) > drag-threshold ||
                       current-offset-y > drag-threshold ||
                       (-current-offset-y) > drag-threshold {
                        was-dragged = true;
                        root.drag-started(node-id, selected);
                    }
                }

                // Report offset to parent
                if was-dragged {
                    root.drag-moved(node-id, current-offset-x / zoom, current-offset-y / zoom);
                }
            }
        }
    }

    // Input pin (green) - with drag-to-link support (on top of body TouchArea)
    input-pin := Rectangle {
        x: 8px * zoom;
        y: (8px + 24px + 8px) * zoom;  // below title bar
        width: pin-size;
        height: pin-size;
        background: input-pin-touch.has-hover ? #66BB6A : #4CAF50;
        border-radius: pin-radius;

        input-pin-touch := TouchArea {
            property <bool> drag-active: false;

            pointer-event(event) => {
                if event.kind == PointerEventKind.down && event.button == PointerEventButton.left {
                    drag-active = true;
                    pin-drag-started(input-pin-id, input-pin-x, input-pin-y);
                }
                if event.kind == PointerEventKind.up && drag-active {
                    drag-active = false;
                    // Calculate position in parent (window) coordinates
                    pin-drag-ended(input-pin-id, input-pin-x + self.mouse-x - pin-radius, input-pin-y + self.mouse-y - pin-radius);
                }
            }
            moved => {
                if drag-active {
                    // Calculate position in parent (window) coordinates
                    pin-drag-moved(input-pin-id, input-pin-x + self.mouse-x - pin-radius, input-pin-y + self.mouse-y - pin-radius);
                }
            }
        }
    }

    // Output pin (blue) - with drag-to-link support (on top of body TouchArea)
    output-pin := Rectangle {
        x: parent.width - 8px * zoom - pin-size;
        y: (8px + 24px + 8px) * zoom;  // below title bar
        width: pin-size;
        height: pin-size;
        background: output-pin-touch.has-hover ? #42A5F5 : #2196F3;
        border-radius: pin-radius;

        output-pin-touch := TouchArea {
            property <bool> drag-active: false;

            pointer-event(event) => {
                if event.kind == PointerEventKind.down && event.button == PointerEventButton.left {
                    drag-active = true;
                    pin-drag-started(output-pin-id, output-pin-x, output-pin-y);
                }
                if event.kind == PointerEventKind.up && drag-active {
                    drag-active = false;
                    // Calculate position in parent (window) coordinates
                    pin-drag-ended(output-pin-id, output-pin-x + self.mouse-x - pin-radius, output-pin-y + self.mouse-y - pin-radius);
                }
            }
            moved => {
                if drag-active {
                    // Calculate position in parent (window) coordinates
                    pin-drag-moved(output-pin-id, output-pin-x + self.mouse-x - pin-radius, output-pin-y + self.mouse-y - pin-radius);
                }
            }
        }
    }

}

export component MainWindow inherits Window {
    title: "Node Editor Example";
    width: 1200px;
    height: 800px;
    background: #1a1a1a;

    // Node model - owned by Rust
    in property <[NodeData]> nodes;

    // Filter node model - owned by Rust (demonstrates complex node type)
    in property <[FilterNodeData]> filter-nodes;

    // Link model - owned by Rust
    in property <[LinkData]> links;

    // Callbacks to Rust for state changes
    callback selection-changed(string);  // comma-separated node IDs
    callback commit-drag(float, float, bool);  // delta-world-x, delta-world-y, snap-to-grid
    callback update-viewport(float, float, float);  // zoom, pan-x, pan-y (for link position updates)
    callback create-link(int, int);  // start-pin-id, end-pin-id
    callback delete-selected-nodes();  // delete all selected nodes
    callback add-node();  // add a new node

    // Filter node callbacks
    callback filter-type-changed(int, int);  // node-id, new-index
    callback filter-toggle-enabled(int);      // node-id
    callback filter-reset(int);               // node-id

    // Pure callback to check if a node is selected (checks core's selection state)
    pure callback is-node-selected(int) -> bool;

    // Grid snap setting
    in-out property <bool> grid-snap-enabled: true;

    // Visual drag offset (tracked in Slint, not affecting model until drag ends)
    property <bool> is-dragging: false;
    property <length> visual-drag-offset-x: 0px;
    property <length> visual-drag-offset-y: 0px;

    // Shared pan state (in-out so Rust can read them)
    in-out property <length> pan-x: 0px;
    in-out property <length> pan-y: 0px;
    in-out property <float> zoom: 1.0;

    // Selection state (managed by editor)
    out property <string> current-selected-ids <=> editor.current-selected-ids;

    // Link hover state (managed by editor)
    out property <int> hovered-link-id <=> editor.hovered-link-id;

    // Link selection state (managed by editor)
    out property <string> current-selected-link-ids <=> editor.current-selected-link-ids;

    // Pure callback to check if a link is selected (parses current-selected-link-ids)
    pure callback is-link-selected(int) -> bool;

    // Pure callback to get link path commands (looks up from link-bezier-paths)
    // This is used during render to get core-generated bezier paths directly
    pure callback get-link-path-commands(int) -> string;

    // Callback to delete selected links (called from Rust)
    callback delete-selected-links();

    // Link position data (managed by editor, updated when viewport/nodes change)
    out property <string> link-positions-data <=> editor.link-positions-data;

    // Core-generated bezier paths for all links (hybrid architecture)
    // Format: "id|path_commands|color_argb;..." where path_commands is SVG like "M x0 y0 C x1 y1 x2 y2 x3 y3"
    in-out property <string> link-bezier-paths <=> editor.link-bezier-paths;

    // Batch of pending links to register (set from Rust)
    // Format: "id,start_pin,end_pin,color_argb;id,start_pin,end_pin,color_argb;..."
    in-out property <string> pending-links-batch <=> editor.pending-links-batch;

    // Batch of link IDs to delete (set from Rust when links are removed)
    // Format: "id1,id2,id3,..."
    in-out property <string> pending-deleted-link-ids <=> editor.pending-deleted-link-ids;

    // Batch of pending node rects to register (set from Rust)
    // Format: "id,x,y,w,h;..." where x,y,w,h are screen coordinates
    in-out property <string> pending-node-rects-batch <=> editor.pending-node-rects-batch;

    // Batch of pending pin positions to register (set from Rust)
    // Format: "pin_id,x,y;..." where x,y are screen coordinates
    in-out property <string> pending-pins-batch <=> editor.pending-pins-batch;

    // Callback to report a link to the editor (called from Rust on init)
    callback report-link(int, int, int, color);  // id, start-pin-id, end-pin-id, color

    // Callback when link positions change (forwarded from editor)
    callback link-positions-updated();

    // Implement report-link to forward to editor
    report-link(id, start-pin, end-pin, col) => {
        editor.reporting-link-id = id;
        editor.reporting-link-start-pin-id = start-pin;
        editor.reporting-link-end-pin-id = end-pin;
        editor.reporting-link-color = col;
    }

    // Compute pin positions from node world coordinates
    // Using global constants from NodeConstants
    pure function compute-input-pin-x(world-x: float) -> length {
        return world-x * 1px * zoom + pan-x + (NodeConstants.pin-margin + NodeConstants.pin-size / 2) * zoom;
    }
    pure function compute-input-pin-y(world-y: float) -> length {
        return world-y * 1px * zoom + pan-y + (NodeConstants.pin-margin + NodeConstants.title-height + NodeConstants.pin-margin + NodeConstants.pin-size / 2) * zoom;
    }
    pure function compute-output-pin-x(world-x: float) -> length {
        return world-x * 1px * zoom + pan-x + (NodeConstants.node-base-width - NodeConstants.pin-margin - NodeConstants.pin-size / 2) * zoom;
    }
    pure function compute-output-pin-y(world-y: float) -> length {
        return world-y * 1px * zoom + pan-y + (NodeConstants.pin-margin + NodeConstants.title-height + NodeConstants.pin-margin + NodeConstants.pin-size / 2) * zoom;
    }

    // The composite NodeEditor handles all three layers:
    // 1. Background with grid
    // 2. Children (nodes and links) - placed via @children
    // 3. Overlay for input handling
    // Plus selection box and link preview rendering
    editor := NodeEditor {
        width: 100%;
        height: 100%;
        pan-x <=> root.pan-x;
        pan-y <=> root.pan-y;
        zoom <=> root.zoom;
        min-zoom: 0.25;
        max-zoom: 4.0;
        background-color: #1a1a1a;
        grid-spacing: 24px;
        grid-color: #333333;

        // Drag state - editor applies offset to link positions when dragging
        is-dragging: is-dragging;
        drag-offset-x: visual-drag-offset-x;
        drag-offset-y: visual-drag-offset-y;

        link-created => {
            // Create link using the editor's output properties
            root.create-link(editor.created-link-start-pin, editor.created-link-end-pin);
        }

        link-dropped => {
            debug("Link dropped on empty space");
        }

        context-menu-requested => {
            debug("Context menu at: " + editor.context-menu-x / 1px + ", " + editor.context-menu-y / 1px);
        }

        selection-changed => {
            // Editor has computed intersecting node IDs and updated selection - notify Rust
            root.selection-changed(editor.current-selected-ids);
        }

        viewport-changed => {
            // Update link positions when pan or zoom changes
            root.update-viewport(zoom, pan-x / 1px, pan-y / 1px);
        }

        delete-selected => {
            // Delete selected nodes and links
            root.delete-selected-nodes();
            root.delete-selected-links();
        }

        add-node-requested => {
            // Add a new node
            root.add-node();
        }

        link-positions-changed => {
            // Editor has updated link positions - notify Rust to sync
            root.link-positions-updated();
        }

        // Nodes - children of NodeEditor
        // Selection state comes from core via is-node-selected callback (not stored in model)
        for node-data in nodes: Node {
            title: node-data.title;
            node-id: node-data.id;
            selected: root.is-node-selected(node-data.id);
            world-x: node-data.world-x * 1px;
            world-y: node-data.world-y * 1px;
            // Pass drag offset to selected nodes
            drag-offset-x: root.is-node-selected(node-data.id) && is-dragging ? visual-drag-offset-x : 0px;
            drag-offset-y: root.is-node-selected(node-data.id) && is-dragging ? visual-drag-offset-y : 0px;
            zoom: zoom;
            pan-x: pan-x;
            pan-y: pan-y;
            clicked(id, shift) => {
                editor.clicked-node-id = id;
                editor.clicked-shift-held = shift;
                root.selection-changed(editor.current-selected-ids);
            }
            drag-started(id, already-selected) => {
                // Only change selection if the node is not already selected
                // This preserves multi-selection when dragging a selected node
                if !already-selected {
                    editor.clicked-node-id = id;
                    editor.clicked-shift-held = false;
                    root.selection-changed(editor.current-selected-ids);
                }

                is-dragging = true;
                visual-drag-offset-x = 0px;
                visual-drag-offset-y = 0px;
            }
            drag-moved(id, offset-x, offset-y) => {
                // Update visual offset for all selected nodes
                visual-drag-offset-x = offset-x;
                visual-drag-offset-y = offset-y;
            }
            drag-ended(id, delta-x, delta-y) => {
                // Commit to model
                root.commit-drag(delta-x / 1px, delta-y / 1px, grid-snap-enabled);
                is-dragging = false;
                visual-drag-offset-x = 0px;
                visual-drag-offset-y = 0px;
            }
            pin-drag-started(pin-id, x, y) => {
                // Start link creation using editor's state machine
                editor.pending-link-pin-id = pin-id;
                editor.pending-link-x = x;
                editor.pending-link-y = y;
                editor.start-link();  // Trigger editor to start link creation
            }
            pin-drag-moved(pin-id, x, y) => {
                // Update link preview end position via editor
                editor.link-end-x = x;
                editor.link-end-y = y;
            }
            pin-drag-ended(pin-id, x, y) => {
                // Complete link creation - editor will use find_pin_at() to find target
                editor.link-end-x = x;
                editor.link-end-y = y;
                editor.complete-link-creation = true;
                // Editor handles validation and fires link-created or link-dropped callback
            }
            report-rect(id, x, y, w, h) => {
                // Append to batch (format: "id,x,y,w,h;...")
                // Convert lengths to floats by dividing by 1px
                editor.pending-node-rects-batch = editor.pending-node-rects-batch +
                    (editor.pending-node-rects-batch == "" ? "" : ";") +
                    id + "," + (x / 1px) + "," + (y / 1px) + "," + (w / 1px) + "," + (h / 1px);
            }
        }

        // Filter nodes - complex nodes with widgets (ComboBox, Buttons, etc.)
        for filter-data in filter-nodes: FilterNode {
            title: filter-data.title;
            node-id: filter-data.id;
            selected: root.is-node-selected(filter-data.id);
            world-x: filter-data.world-x * 1px;
            world-y: filter-data.world-y * 1px;
            drag-offset-x: root.is-node-selected(filter-data.id) && is-dragging ? visual-drag-offset-x : 0px;
            drag-offset-y: root.is-node-selected(filter-data.id) && is-dragging ? visual-drag-offset-y : 0px;
            zoom: zoom;
            pan-x: pan-x;
            pan-y: pan-y;
            filter-type-index: filter-data.filter-type-index;
            enabled: filter-data.enabled;
            processed-count: filter-data.processed-count;

            clicked(id, shift) => {
                editor.clicked-node-id = id;
                editor.clicked-shift-held = shift;
                root.selection-changed(editor.current-selected-ids);
            }
            drag-started(id, already-selected) => {
                if !already-selected {
                    editor.clicked-node-id = id;
                    editor.clicked-shift-held = false;
                    root.selection-changed(editor.current-selected-ids);
                }
                is-dragging = true;
                visual-drag-offset-x = 0px;
                visual-drag-offset-y = 0px;
            }
            drag-moved(id, offset-x, offset-y) => {
                visual-drag-offset-x = offset-x;
                visual-drag-offset-y = offset-y;
            }
            drag-ended(id, delta-x, delta-y) => {
                root.commit-drag(delta-x / 1px, delta-y / 1px, grid-snap-enabled);
                is-dragging = false;
                visual-drag-offset-x = 0px;
                visual-drag-offset-y = 0px;
            }
            pin-drag-started(pin-id, x, y) => {
                editor.pending-link-pin-id = pin-id;
                editor.pending-link-x = x;
                editor.pending-link-y = y;
                editor.start-link();
            }
            pin-drag-moved(pin-id, x, y) => {
                editor.link-end-x = x;
                editor.link-end-y = y;
            }
            pin-drag-ended(pin-id, x, y) => {
                editor.link-end-x = x;
                editor.link-end-y = y;
                editor.complete-link-creation = true;
            }
            report-rect(id, x, y, w, h) => {
                editor.pending-node-rects-batch = editor.pending-node-rects-batch +
                    (editor.pending-node-rects-batch == "" ? "" : ";") +
                    id + "," + (x / 1px) + "," + (y / 1px) + "," + (w / 1px) + "," + (h / 1px);
            }
            filter-type-changed(id, idx) => {
                root.filter-type-changed(id, idx);
            }
            toggle-enabled(id) => {
                root.filter-toggle-enabled(id);
            }
            reset-clicked(id) => {
                root.filter-reset(id);
            }
        }

        // Links - children of NodeEditor
        // Uses core-generated bezier path commands (hybrid architecture)
        // Path commands are looked up from core via pure callback (not from model)
        for link-data in links: Link {
            path-commands: get-link-path-commands(link-data.id);
            // Highlight link when selected (cyan) or hovered (white)
            link-color: is-link-selected(link-data.id) ? #00ffff :
                        link-data.id == hovered-link-id ? #ffffff : link-data.color;
            line-width: is-link-selected(link-data.id) ? 4px * zoom :
                        link-data.id == hovered-link-id ? 4px * zoom : 3px * zoom;
        }
    }

    // Instructions overlay
    Rectangle {
        x: 10px;
        y: 10px;
        width: 280px;
        height: 200px;
        background: #00000080;
        border-radius: 8px;

        VerticalLayout {
            padding: 12px;
            spacing: 4px;

            Text { text: "Node Editor Controls:"; color: #fff; font-size: 14px; font-weight: 600; }
            Text { text: "Middle mouse: Pan"; color: #ccc; font-size: 12px; }
            Text { text: "Scroll wheel: Zoom"; color: #ccc; font-size: 12px; }
            Text { text: "Drag nodes to move them"; color: #ccc; font-size: 12px; }
            Text { text: "Drag from pin: Create link"; color: #ccc; font-size: 12px; }
            Text { text: "Ctrl+drag: Box select"; color: #ccc; font-size: 12px; }
            Text { text: "Shift+click: Extend selection"; color: #ccc; font-size: 12px; }

            Rectangle { height: 8px; } // Spacer

            HorizontalLayout {
                spacing: 8px;
                alignment: start;

                // Custom checkbox
                Rectangle {
                    width: 16px;
                    height: 16px;
                    border-radius: 3px;
                    border-width: 1px;
                    border-color: #888;
                    background: grid-snap-enabled ? #4a9eff : #333;

                    // Checkmark
                    Text {
                        text: grid-snap-enabled ? "âœ“" : "";
                        color: white;
                        font-size: 12px;
                        horizontal-alignment: center;
                        vertical-alignment: center;
                    }

                    TouchArea {
                        clicked => {
                            grid-snap-enabled = !grid-snap-enabled;
                        }
                    }
                }
                Text {
                    text: "Snap to grid";
                    color: #ccc;
                    font-size: 12px;
                    vertical-alignment: center;
                }
            }
        }
    }

    // Debug info
    Rectangle {
        x: parent.width - 160px;
        y: parent.height - 40px;
        width: 150px;
        height: 30px;
        background: #00000080;
        border-radius: 4px;

        Text {
            text: "Pins: " + editor.debug-pin-count + " Links: " + editor.debug-link-count;
            color: #aaa;
            font-size: 11px;
            horizontal-alignment: center;
            vertical-alignment: center;
        }
    }

    // Zoom indicator
    Rectangle {
        x: parent.width - 110px;
        y: 10px;
        width: 100px;
        height: 30px;
        background: #00000080;
        border-radius: 4px;

        Text {
            text: "Zoom: " + round(zoom * 100) + "%";
            color: white;
            horizontal-alignment: center;
            vertical-alignment: center;
        }
    }
}
