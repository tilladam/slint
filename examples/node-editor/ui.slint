// Simple Node Editor Example

// A bezier link between two pins
component Link inherits Path {
    in property <length> start-x;
    in property <length> start-y;
    in property <length> end-x;
    in property <length> end-y;
    in property <color> link-color: #888888;
    in property <length> line-width: 2px;
    in property <float> zoom: 1.0;

    // Calculate control point offset (horizontal bezier)
    property <length> dx: abs(end-x - start-x);
    property <length> offset: max(dx * 0.5, 50px * zoom);

    // Control points
    property <length> ctrl1-x: start-x + offset;
    property <length> ctrl1-y: start-y;
    property <length> ctrl2-x: end-x - offset;
    property <length> ctrl2-y: end-y;

    width: 100%;
    height: 100%;
    stroke: link-color;
    stroke-width: line-width;
    fill: transparent;

    // Set viewbox to match actual size so SVG coordinates map 1:1
    // Use max() to avoid zero-size viewbox during initial layout
    viewbox-x: 0;
    viewbox-y: 0;
    viewbox-width: max(self.width / 1px, 1);
    viewbox-height: max(self.height / 1px, 1);

    // SVG path command: M (move to), C (cubic bezier)
    commands: "M " + start-x / 1px + " " + start-y / 1px +
              " C " + ctrl1-x / 1px + " " + ctrl1-y / 1px +
              " " + ctrl2-x / 1px + " " + ctrl2-y / 1px +
              " " + end-x / 1px + " " + end-y / 1px;
}

// A basic node component with interactive pins
component Node inherits Rectangle {
    in property <string> title: "Node";
    in property <int> node-id;
    in property <int> input-pin-id: node-id * 10 + 1;   // e.g., node 1 -> pin 11
    in property <int> output-pin-id: node-id * 10 + 2;  // e.g., node 1 -> pin 12

    // Selection state
    in property <bool> selected: false;

    // World coordinates (grid space) - these are what get modified by dragging
    in-out property <length> world-x;
    in-out property <length> world-y;

    // Transform parameters (from parent)
    in property <float> zoom: 1.0;
    in property <length> pan-x: 0px;
    in property <length> pan-y: 0px;

    // Callbacks for pin drag-to-link (pin-id, x, y)
    callback pin-drag-started(int, length, length);
    callback pin-drag-moved(int, length, length);
    callback pin-drag-ended(int, length, length);

    // Callback when node is clicked (for selection) - passes node-id and shift-held
    callback clicked(int, bool);

    // Pin dimensions (scaled by zoom)
    property <length> base-pin-size: 12px;
    property <length> pin-size: base-pin-size * zoom;
    property <length> pin-radius: pin-size / 2;

    // Base dimensions
    property <length> base-width: 150px;
    property <length> base-height: 80px;

    // Screen position calculated from world position
    property <length> screen-x: world-x * zoom + pan-x;
    property <length> screen-y: world-y * zoom + pan-y;

    // Expose pin positions (center of pin circles, in parent coordinates)
    out property <length> input-pin-x: screen-x + input-pin.x + pin-radius;
    out property <length> input-pin-y: screen-y + input-pin.y + pin-radius;
    out property <length> output-pin-x: screen-x + output-pin.x + pin-radius;
    out property <length> output-pin-y: screen-y + output-pin.y + pin-radius;

    x: screen-x;
    y: screen-y;
    width: base-width * zoom;
    height: base-height * zoom;
    background: selected ? #3a3a4a : #2d2d2d;
    border-radius: 8px * zoom;
    border-width: selected ? 2px * zoom : 1px * zoom;
    border-color: selected ? #4a9eff : #555;

    // Title bar
    Rectangle {
        x: 8px * zoom;
        y: 8px * zoom;
        width: parent.width - 16px * zoom;
        height: 24px * zoom;
        background: selected ? #4a6a9a : #3d3d3d;
        border-radius: 4px * zoom;

        Text {
            text: title;
            color: white;
            font-size: 14px * zoom;
            horizontal-alignment: center;
            vertical-alignment: center;
        }
    }

    // Drag handling for the node body (must be before pins so pins are on top)
    TouchArea {
        property <bool> shift-held: false;
        property <bool> was-dragged: false;
        property <length> drag-threshold: 5px;
        // Store absolute screen position of mouse at press time
        property <length> press-abs-x;
        property <length> press-abs-y;
        // Store original world position when drag starts
        property <length> drag-start-world-x;
        property <length> drag-start-world-y;

        pointer-event(event) => {
            if event.kind == PointerEventKind.down && event.button == PointerEventButton.left {
                shift-held = event.modifiers.shift;
                was-dragged = false;
                // Capture absolute screen position of mouse (node position + relative mouse pos)
                press-abs-x = screen-x + self.mouse-x;
                press-abs-y = screen-y + self.mouse-y;
                // Remember where the node was when we started
                drag-start-world-x = world-x;
                drag-start-world-y = world-y;
            }
            if event.kind == PointerEventKind.up && event.button == PointerEventButton.left {
                // Only trigger click if we didn't drag
                if !was-dragged {
                    root.clicked(node-id, shift-held);
                }
            }
        }
        moved => {
            if self.pressed {
                // Calculate current absolute mouse position
                // (node screen pos + relative mouse pos = absolute screen pos)
                // Note: screen-x/y change as we drag, but screen-x + mouse-x stays constant
                // for a given screen mouse position

                // Check threshold using relative coords (these don't have feedback issues)
                if !was-dragged {
                    if self.mouse-x - self.pressed-x > drag-threshold ||
                       self.pressed-x - self.mouse-x > drag-threshold ||
                       self.mouse-y - self.pressed-y > drag-threshold ||
                       self.pressed-y - self.mouse-y > drag-threshold {
                        was-dragged = true;
                    }
                }

                // If dragging, compute delta using absolute screen coordinates
                if was-dragged {
                    // Current absolute mouse position
                    // screen-x + mouse-x gives absolute position regardless of node movement
                    world-x = drag-start-world-x + (screen-x + self.mouse-x - press-abs-x) / zoom;
                    world-y = drag-start-world-y + (screen-y + self.mouse-y - press-abs-y) / zoom;
                }
            }
        }
    }

    // Input pin (green) - with drag-to-link support (on top of body TouchArea)
    input-pin := Rectangle {
        x: 8px * zoom;
        y: (8px + 24px + 8px) * zoom;  // below title bar
        width: pin-size;
        height: pin-size;
        background: input-pin-touch.has-hover ? #66BB6A : #4CAF50;
        border-radius: pin-radius;

        input-pin-touch := TouchArea {
            property <bool> drag-active: false;

            pointer-event(event) => {
                if event.kind == PointerEventKind.down && event.button == PointerEventButton.left {
                    drag-active = true;
                    pin-drag-started(input-pin-id, input-pin-x, input-pin-y);
                }
                if event.kind == PointerEventKind.up && drag-active {
                    drag-active = false;
                    // Calculate position in parent (window) coordinates
                    pin-drag-ended(input-pin-id, input-pin-x + self.mouse-x - pin-radius, input-pin-y + self.mouse-y - pin-radius);
                }
            }
            moved => {
                if drag-active {
                    // Calculate position in parent (window) coordinates
                    pin-drag-moved(input-pin-id, input-pin-x + self.mouse-x - pin-radius, input-pin-y + self.mouse-y - pin-radius);
                }
            }
        }
    }

    // Output pin (blue) - with drag-to-link support (on top of body TouchArea)
    output-pin := Rectangle {
        x: parent.width - 8px * zoom - pin-size;
        y: (8px + 24px + 8px) * zoom;  // below title bar
        width: pin-size;
        height: pin-size;
        background: output-pin-touch.has-hover ? #42A5F5 : #2196F3;
        border-radius: pin-radius;

        output-pin-touch := TouchArea {
            property <bool> drag-active: false;

            pointer-event(event) => {
                if event.kind == PointerEventKind.down && event.button == PointerEventButton.left {
                    drag-active = true;
                    pin-drag-started(output-pin-id, output-pin-x, output-pin-y);
                }
                if event.kind == PointerEventKind.up && drag-active {
                    drag-active = false;
                    // Calculate position in parent (window) coordinates
                    pin-drag-ended(output-pin-id, output-pin-x + self.mouse-x - pin-radius, output-pin-y + self.mouse-y - pin-radius);
                }
            }
            moved => {
                if drag-active {
                    // Calculate position in parent (window) coordinates
                    pin-drag-moved(output-pin-id, output-pin-x + self.mouse-x - pin-radius, output-pin-y + self.mouse-y - pin-radius);
                }
            }
        }
    }
}

export component MainWindow inherits Window {
    title: "Node Editor Example";
    width: 1200px;
    height: 800px;
    background: #1a1a1a;

    // Shared pan state
    property <length> pan-x: 0px;
    property <length> pan-y: 0px;
    property <float> zoom: 1.0;

    // The three-layer node editor structure
    NodeEditorBackground {
        width: 100%;
        height: 100%;
        pan-x <=> pan-x;
        pan-y <=> pan-y;
        zoom: zoom;
        grid-spacing: 24px;
        grid-color: #333333;
        background-color: #1a1a1a;
    }

    // Node selection state (individual booleans for multi-select)
    property <bool> node-1-selected: false;
    property <bool> node-2-selected: false;
    property <bool> node-3-selected: false;

    function select-node(node-id: int, shift-held: bool) {
        if shift-held {
            // Shift+click: toggle this node without affecting others
            if node-id == 1 {
                node-1-selected = !node-1-selected;
            } else if node-id == 2 {
                node-2-selected = !node-2-selected;
            } else if node-id == 3 {
                node-3-selected = !node-3-selected;
            }
        } else {
            // Normal click: select only this node (clear others)
            node-1-selected = node-id == 1;
            node-2-selected = node-id == 2;
            node-3-selected = node-id == 3;
        }
    }

    // Check if a node intersects with the current selection box
    pure function node-in-selection(node-x: length, node-y: length, node-w: length, node-h: length) -> bool {
        // Two rectangles intersect if they overlap on both axes
        return node-x < overlay.selection-x + overlay.selection-width &&
               node-x + node-w > overlay.selection-x &&
               node-y < overlay.selection-y + overlay.selection-height &&
               node-y + node-h > overlay.selection-y;
    }

    // Update selection based on box select - selects ALL nodes in box
    function update-box-selection() {
        // Only process if selection box has meaningful size
        if overlay.selection-width > 5px && overlay.selection-height > 5px {
            // Select all nodes that intersect with the selection box
            node-1-selected = node-in-selection(input-node.x, input-node.y, input-node.width, input-node.height);
            node-2-selected = node-in-selection(process-node.x, process-node.y, process-node.width, process-node.height);
            node-3-selected = node-in-selection(output-node.x, output-node.y, output-node.width, output-node.height);
        }
    }

    // Link creation state managed directly in Slint
    property <bool> link-active: false;
    property <int> link-pin-id: 0;
    property <length> link-start-x: 0px;
    property <length> link-start-y: 0px;
    property <length> link-end-x: 0px;
    property <length> link-end-y: 0px;

    // Hit radius for pin detection (in screen pixels, scales with zoom)
    property <length> pin-hit-radius: 15px * zoom;

    // User-created links (up to 10 dynamic links for this example)
    // Each link stores: enabled, start-pin-id, end-pin-id
    property <bool> user-link-0-enabled: false;
    property <int> user-link-0-start: 0;
    property <int> user-link-0-end: 0;
    property <bool> user-link-1-enabled: false;
    property <int> user-link-1-start: 0;
    property <int> user-link-1-end: 0;
    property <bool> user-link-2-enabled: false;
    property <int> user-link-2-start: 0;
    property <int> user-link-2-end: 0;

    // Helper: check if point is near a pin (returns pin-id or 0)
    pure function point-near-pin(x: length, y: length, pin-x: length, pin-y: length, pin-id: int) -> int {
        if (x - pin-x) * (x - pin-x) + (y - pin-y) * (y - pin-y) < pin-hit-radius * pin-hit-radius {
            return pin-id;
        }
        return 0;
    }

    // Helper: check if pin is an input pin (pin-id ends in 1)
    pure function is-input-pin(pin-id: int) -> bool {
        return mod(pin-id, 10) == 1;
    }

    // Helper: check if pin is an output pin (pin-id ends in 2)
    pure function is-output-pin(pin-id: int) -> bool {
        return mod(pin-id, 10) == 2;
    }

    // Helper: get pin position by id
    pure function get-pin-x(pin-id: int) -> length {
        // Node 1 pins: 11 (input), 12 (output)
        if pin-id == 11 { return input-node.input-pin-x; }
        if pin-id == 12 { return input-node.output-pin-x; }
        // Node 2 pins: 21 (input), 22 (output)
        if pin-id == 21 { return process-node.input-pin-x; }
        if pin-id == 22 { return process-node.output-pin-x; }
        // Node 3 pins: 31 (input), 32 (output)
        if pin-id == 31 { return output-node.input-pin-x; }
        if pin-id == 32 { return output-node.output-pin-x; }
        return 0px;
    }

    pure function get-pin-y(pin-id: int) -> length {
        if pin-id == 11 { return input-node.input-pin-y; }
        if pin-id == 12 { return input-node.output-pin-y; }
        if pin-id == 21 { return process-node.input-pin-y; }
        if pin-id == 22 { return process-node.output-pin-y; }
        if pin-id == 31 { return output-node.input-pin-y; }
        if pin-id == 32 { return output-node.output-pin-y; }
        return 0px;
    }

    // Find which pin (if any) is at position
    pure function find-pin-at(x: length, y: length) -> int {
        // Check all pins
        if point-near-pin(x, y, input-node.input-pin-x, input-node.input-pin-y, 11) != 0 { return 11; }
        if point-near-pin(x, y, input-node.output-pin-x, input-node.output-pin-y, 12) != 0 { return 12; }
        if point-near-pin(x, y, process-node.input-pin-x, process-node.input-pin-y, 21) != 0 { return 21; }
        if point-near-pin(x, y, process-node.output-pin-x, process-node.output-pin-y, 22) != 0 { return 22; }
        if point-near-pin(x, y, output-node.input-pin-x, output-node.input-pin-y, 31) != 0 { return 31; }
        if point-near-pin(x, y, output-node.output-pin-x, output-node.output-pin-y, 32) != 0 { return 32; }
        return 0;
    }

    // Create a link between two pins
    function create-link(start-pin: int, end-pin: int) {
        // Find first available slot
        if !user-link-0-enabled {
            user-link-0-enabled = true;
            user-link-0-start = start-pin;
            user-link-0-end = end-pin;
        } else if !user-link-1-enabled {
            user-link-1-enabled = true;
            user-link-1-start = start-pin;
            user-link-1-end = end-pin;
        } else if !user-link-2-enabled {
            user-link-2-enabled = true;
            user-link-2-start = start-pin;
            user-link-2-end = end-pin;
        }
        debug("Link created: " + start-pin + " -> " + end-pin);
    }

    // Helper functions for link creation
    function start-link-creation(pin-id: int, x: length, y: length) {
        link-active = true;
        link-pin-id = pin-id;
        link-start-x = x;
        link-start-y = y;
        link-end-x = x;
        link-end-y = y;
    }

    function update-link-position(pin-id: int, x: length, y: length) {
        if link-active && link-pin-id == pin-id {
            link-end-x = x;
            link-end-y = y;
        }
    }

    // Temporary storage for hit-testing result
    property <int> drop-target-pin: 0;

    function end-link-creation(pin-id: int, x: length, y: length) {
        if link-active && link-pin-id == pin-id {
            // Check if we're dropping on a valid target pin
            drop-target-pin = find-pin-at(x, y);

            if drop-target-pin != 0 && drop-target-pin != pin-id {
                // Validate: output should connect to input (or vice versa)
                if (is-output-pin(pin-id) && is-input-pin(drop-target-pin)) ||
                   (is-input-pin(pin-id) && is-output-pin(drop-target-pin)) {
                    // Normalize: always store output -> input
                    if is-output-pin(pin-id) {
                        create-link(pin-id, drop-target-pin);
                    } else {
                        create-link(drop-target-pin, pin-id);
                    }
                }
            }

            link-active = false;
            link-pin-id = 0;
        }
    }

    // Nodes layer - world coordinates transformed to screen by Node component
    input-node := Node {
        title: "Input";
        node-id: 1;
        selected: node-1-selected;
        world-x: 100px;
        world-y: 200px;
        zoom: zoom;
        pan-x: pan-x;
        pan-y: pan-y;
        clicked(id, shift) => { select-node(id, shift); }
        pin-drag-started(pin-id, x, y) => { start-link-creation(pin-id, x, y); }
        pin-drag-moved(pin-id, x, y) => { update-link-position(pin-id, x, y); }
        pin-drag-ended(pin-id, x, y) => { end-link-creation(pin-id, x, y); }
    }

    process-node := Node {
        title: "Process";
        node-id: 2;
        selected: node-2-selected;
        world-x: 350px;
        world-y: 150px;
        zoom: zoom;
        pan-x: pan-x;
        pan-y: pan-y;
        clicked(id, shift) => { select-node(id, shift); }
        pin-drag-started(pin-id, x, y) => { start-link-creation(pin-id, x, y); }
        pin-drag-moved(pin-id, x, y) => { update-link-position(pin-id, x, y); }
        pin-drag-ended(pin-id, x, y) => { end-link-creation(pin-id, x, y); }
    }

    output-node := Node {
        title: "Output";
        node-id: 3;
        selected: node-3-selected;
        world-x: 600px;
        world-y: 200px;
        zoom: zoom;
        pan-x: pan-x;
        pan-y: pan-y;
        clicked(id, shift) => { select-node(id, shift); }
        pin-drag-started(pin-id, x, y) => { start-link-creation(pin-id, x, y); }
        pin-drag-moved(pin-id, x, y) => { update-link-position(pin-id, x, y); }
        pin-drag-ended(pin-id, x, y) => { end-link-creation(pin-id, x, y); }
    }

    // Links layer (between nodes and overlay)
    // Link from Input's output to Process's input
    Link {
        start-x: input-node.output-pin-x;
        start-y: input-node.output-pin-y;
        end-x: process-node.input-pin-x;
        end-y: process-node.input-pin-y;
        link-color: #ff9800;
        line-width: 3px * zoom;
        zoom: zoom;
    }

    // Link from Process's output to Output's input
    Link {
        start-x: process-node.output-pin-x;
        start-y: process-node.output-pin-y;
        end-x: output-node.input-pin-x;
        end-y: output-node.input-pin-y;
        link-color: #2196f3;
        line-width: 3px * zoom;
        zoom: zoom;
    }

    // User-created links (dynamic)
    Link {
        visible: user-link-0-enabled;
        start-x: get-pin-x(user-link-0-start);
        start-y: get-pin-y(user-link-0-start);
        end-x: get-pin-x(user-link-0-end);
        end-y: get-pin-y(user-link-0-end);
        link-color: #4caf50;
        line-width: 3px * zoom;
        zoom: zoom;
    }

    Link {
        visible: user-link-1-enabled;
        start-x: get-pin-x(user-link-1-start);
        start-y: get-pin-y(user-link-1-start);
        end-x: get-pin-x(user-link-1-end);
        end-y: get-pin-y(user-link-1-end);
        link-color: #9c27b0;
        line-width: 3px * zoom;
        zoom: zoom;
    }

    Link {
        visible: user-link-2-enabled;
        start-x: get-pin-x(user-link-2-start);
        start-y: get-pin-y(user-link-2-start);
        end-x: get-pin-x(user-link-2-end);
        end-y: get-pin-y(user-link-2-end);
        link-color: #e91e63;
        line-width: 3px * zoom;
        zoom: zoom;
    }

    // Overlay layer (on top)
    overlay := NodeEditorOverlay {
        width: 100%;
        height: 100%;
        pan-x <=> pan-x;
        pan-y <=> pan-y;
        zoom <=> zoom;
        min-zoom: 0.25;
        max-zoom: 4.0;
        selection-box-color: #4488ff40;
        active-link-color: #ffffff;

        link-created => {
            debug("Link created");
        }

        link-dropped => {
            debug("Link dropped");
        }

        context-menu-requested => {
            debug("Context menu at: " + overlay.context-menu-x / 1px + ", " + overlay.context-menu-y / 1px);
        }

        selection-changed => {
            update-box-selection();
        }
    }

    // Selection box (rendered based on overlay state)
    Rectangle {
        visible: overlay.is-selecting;
        x: overlay.selection-x;
        y: overlay.selection-y;
        width: overlay.selection-width;
        height: overlay.selection-height;
        background: #4488ff20;
        border-color: #4488ff;
        border-width: 1px;
    }

    // Active link preview (rendered during link creation)
    Link {
        visible: link-active;
        start-x: link-start-x;
        start-y: link-start-y;
        end-x: link-end-x;
        end-y: link-end-y;
        link-color: #ffffff80;
        line-width: 2px * zoom;
        zoom: zoom;
    }

    // Instructions overlay
    Rectangle {
        x: 10px;
        y: 10px;
        width: 280px;
        height: 155px;
        background: #00000080;
        border-radius: 8px;

        VerticalLayout {
            padding: 12px;
            spacing: 4px;

            Text { text: "Node Editor Controls:"; color: #fff; font-size: 14px; font-weight: 600; }
            Text { text: "Middle mouse: Pan"; color: #ccc; font-size: 12px; }
            Text { text: "Scroll wheel: Zoom"; color: #ccc; font-size: 12px; }
            Text { text: "Drag nodes to move them"; color: #ccc; font-size: 12px; }
            Text { text: "Drag from pin: Create link"; color: #ccc; font-size: 12px; }
            Text { text: "Ctrl+drag: Box select"; color: #ccc; font-size: 12px; }
            Text { text: "Shift+click: Extend selection"; color: #ccc; font-size: 12px; }
        }
    }

    // Zoom indicator
    Rectangle {
        x: parent.width - 110px;
        y: 10px;
        width: 100px;
        height: 30px;
        background: #00000080;
        border-radius: 4px;

        Text {
            text: "Zoom: " + round(zoom * 100) + "%";
            color: white;
            horizontal-alignment: center;
            vertical-alignment: center;
        }
    }
}
