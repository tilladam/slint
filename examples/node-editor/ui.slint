// Node Editor Example
//
// This example demonstrates the NodeEditor composite component which wraps
// NodeEditorBackground and NodeEditorOverlay into a convenient three-layer
// architecture.
//
// The composite handles:
// - Grid background rendering
// - Pan and zoom
// - Box selection
// - Link creation with bezier preview
// - Selection box rendering
//
// Usage pattern:
// 1. Add nodes as children of NodeEditor
// 2. Add links as children (using Link component)
// 3. Handle callbacks for link creation, selection changes, etc.

import { NodeEditor, Link, Pin, PinTypes, PinId, MinimapNode, BaseNode, NodeLayout } from "std-widgets.slint";
import { InstructionsOverlay } from "instructions_overlay.slint";

// Re-export NodeLayout for Rust access (as NodeConstants for backward compatibility)
export global NodeConstants {
    out property <length> node-base-width <=> NodeLayout.node-base-width;
    out property <length> node-base-height <=> NodeLayout.node-base-height;
    out property <length> pin-size <=> NodeLayout.pin-size;
    out property <length> pin-margin <=> NodeLayout.pin-margin;
    out property <length> title-height <=> NodeLayout.title-height;
    out property <length> grid-spacing <=> NodeLayout.grid-spacing;
}

export global FilterNodeConstants {
    out property <length> base-width: 260px;
    out property <length> base-height: 148px;  // 8 + 28 + 8 + 32*3 + 8
    out property <length> pin-size: 12px;
    out property <length> pin-margin: 4px;
    out property <length> content-padding: 8px;
    out property <length> title-height: 28px;
    out property <length> row-height: 32px;
}
import { FilterNode, FilterNodeData } from "filter_node.slint";

// Re-export standard data structures from library for Rust
export { NodeData, LinkData }

// Re-export FilterNodeData for Rust
export { FilterNodeData }


// A basic node component with interactive pins
component Node inherits BaseNode {
    in property <string> title: "Node";
    in property <int> input-pin-id: PinId.make(self.node-id, PinTypes.input);
    in property <int> output-pin-id: PinId.make(self.node-id, PinTypes.output);

    // Pin dimensions (scaled by zoom)
    property <length> pin-size: NodeConstants.pin-size * self.zoom;
    property <length> pin-radius: pin-size / 2;

    // Base dimensions (from global constants)
    property <length> base-width: NodeConstants.node-base-width;
    property <length> base-height: NodeConstants.node-base-height;

    // Expose pin positions (center of pin circles, in parent coordinates)
    out property <length> input-pin-x: self.screen-x + input-pin.center-x;
    out property <length> input-pin-y: self.screen-y + input-pin.center-y;
    out property <length> output-pin-x: self.screen-x + output-pin.center-x;
    out property <length> output-pin-y: self.screen-y + output-pin.center-y;

    // Set dimensions
    width: base-width * self.zoom;
    height: base-height * self.zoom;

    // Title bar
    Rectangle {
        x: 8px * root.zoom;
        y: 8px * root.zoom;
        width: parent.width - 16px * root.zoom;
        height: 24px * root.zoom;
        background: root.selected ? #4a6a9a : #3d3d3d;
        border-radius: 4px * root.zoom;

        Text {
            text: root.title;
            color: white;
            font-size: 14px * root.zoom;
            horizontal-alignment: center;
            vertical-alignment: center;
        }
    }

    // Input pin (green) - with drag-to-link support (on top of body TouchArea)
    input-pin := Pin {
        x: 8px * root.zoom;
        y: (8px + 24px + 8px) * root.zoom;  // below title bar
        pin-id: root.input-pin-id;
        zoom: root.zoom;
        node-screen-x: root.screen-x;
        node-screen-y: root.screen-y;
        base-color: #4CAF50;
        hover-color: #66BB6A;
        base-size: NodeConstants.pin-size;
        drag-started(id, x, y) => { root.pin-drag-started(id, x, y); }
        drag-moved(id, x, y) => { root.pin-drag-moved(id, x, y); }
        drag-ended(id, x, y) => { root.pin-drag-ended(id, x, y); }
        report-position(id, x, y) => { root.pin-position-changed(id, x, y); }
    }

    // Output pin (blue) - with drag-to-link support (on top of body TouchArea)
    output-pin := Pin {
        x: parent.width - 8px * root.zoom - root.pin-size;
        y: (8px + 24px + 8px) * root.zoom;  // below title bar
        pin-id: root.output-pin-id;
        zoom: root.zoom;
        node-screen-x: root.screen-x;
        node-screen-y: root.screen-y;
        base-color: #2196F3;
        hover-color: #42A5F5;
        base-size: NodeConstants.pin-size;
        drag-started(id, x, y) => { root.pin-drag-started(id, x, y); }
        drag-moved(id, x, y) => { root.pin-drag-moved(id, x, y); }
        drag-ended(id, x, y) => { root.pin-drag-ended(id, x, y); }
        report-position(id, x, y) => { root.pin-position-changed(id, x, y); }
    }
}

export component MainWindow inherits Window {
    title: "Node Editor Example";
    width: 1200px;
    height: 800px;
    background: #1a1a1a;

    // Node model - owned by Rust
    in property <[NodeData]> nodes;

    // Filter node model - owned by Rust (demonstrates complex node type)
    in property <[FilterNodeData]> filter-nodes;

    // Link model - owned by Rust
    in property <[LinkData]> links;

    // Callbacks to Rust for state changes
    callback selection-changed(string);  // comma-separated node IDs
    callback commit-drag(float, float);  // delta-world-x, delta-world-y (already snapped if enabled)
    callback update-viewport(float, float, float);  // zoom, pan-x, pan-y (for link position updates)
    callback create-link(int, int);  // start-pin-id, end-pin-id
    callback delete-selected-nodes();  // delete all selected nodes
    callback add-node();  // add a new node

    // Filter node callbacks
    callback filter-type-changed(int, int);  // node-id, new-index
    callback filter-toggle-enabled(int);      // node-id
    callback filter-reset(int);               // node-id

    // Pure callback to check if a node is selected
    // Forward to editor's built-in is-selected callback
    pure callback is-node-selected(int) -> bool;

    // Pure function to snap a value to the grid
    pure public function snap-to-grid(value: float) -> float {
        return editor.snap-to-grid(value);
    }

    // Grid snap toggle (bound to editor.grid-snapping)
    property <bool> grid-snap-enabled: true;

    // Shared pan state (in-out so Rust can read them)
    in-out property <length> pan-x: 0px;
    in-out property <length> pan-y: 0px;
    in-out property <float> zoom: 1.0;

    // Selection state (managed by editor)
    out property <string> current-selected-ids <=> editor.current-selected-ids;

    // Link hover state (managed by editor)
    out property <int> hovered-link-id <=> editor.hovered-link-id;

    // Link selection state (managed by editor)
    out property <string> current-selected-link-ids <=> editor.current-selected-link-ids;

    // Pure callback to check if a link is selected (parses current-selected-link-ids)
    pure callback is-link-selected(int) -> bool;

    // Callback to delete selected links (called from Rust)
    callback delete-selected-links();

    // Structured bezier path data for all links
    out property <[LinkPath]> link-paths <=> editor.link-paths;

    // Batch of pending links to register (set from Rust)
    // Format: "id,start_pin,end_pin,color_argb;id,start_pin,end_pin,color_argb;..."
    in-out property <string> pending-links-batch <=> editor.pending-links-batch;

    // Batch of link IDs to delete (set from Rust when links are removed)
    // Format: "id1,id2,id3,..."
    in-out property <string> pending-deleted-link-ids <=> editor.pending-deleted-link-ids;

    // Batch of pending node rects to register (set from Rust)
    // Format: "id,x,y,w,h;..." where x,y,w,h are screen coordinates
    in-out property <string> pending-node-rects-batch <=> editor.pending-node-rects-batch;

    // Batch of pending pin positions to register (set from Rust)
    // Format: "pin_id,x,y;..." where x,y are screen coordinates
    in-out property <string> pending-pins-batch <=> editor.pending-pins-batch;

    // === Minimap properties ===
    in property <bool> minimap-enabled <=> editor.minimap-enabled;
    in property <[MinimapNode]> minimap-nodes <=> editor.minimap-nodes;
    in-out property <length> graph-min-x <=> editor.graph-min-x;
    in-out property <length> graph-min-y <=> editor.graph-min-y;
    in-out property <length> graph-max-x <=> editor.graph-max-x;
    in-out property <length> graph-max-y <=> editor.graph-max-y;

    // Callback when link positions change (forwarded from editor)
    callback link-positions-updated();

    // Pure callbacks to compute screen positions from world coordinates
    // These use Slint globals as the single source of truth - callable from Rust
    pure callback compute-node-screen-x(float) -> length;
    pure callback compute-node-screen-y(float) -> length;
    pure callback compute-node-screen-width() -> length;
    pure callback compute-node-screen-height() -> length;

    // Compute pin positions from node world coordinates (absolute screen coords)
    pure callback compute-input-pin-x(float) -> length;
    pure callback compute-input-pin-y(float) -> length;
    pure callback compute-output-pin-x(float) -> length;
    pure callback compute-output-pin-y(float) -> length;

    // Compute pin offsets from node origin (relative, unscaled, for core recomputation)
    pure callback compute-input-pin-relative-x() -> length;
    pure callback compute-input-pin-relative-y() -> length;
    pure callback compute-output-pin-relative-x() -> length;
    pure callback compute-output-pin-relative-y() -> length;

    // Filter node position computation
    pure callback compute-filter-screen-width() -> length;
    pure callback compute-filter-screen-height() -> length;

    // Filter node pin positions (absolute screen coords)
    pure callback compute-filter-data-input-pin-x(float) -> length;
    pure callback compute-filter-data-input-pin-y(float) -> length;
    pure callback compute-filter-data-output-pin-x(float) -> length;
    pure callback compute-filter-data-output-pin-y(float) -> length;
    pure callback compute-filter-control-input-pin-x(float) -> length;
    pure callback compute-filter-control-input-pin-y(float) -> length;

    // Filter node pin relative offsets (unscaled, from node origin)
    pure callback compute-filter-data-input-pin-relative-x() -> length;
    pure callback compute-filter-data-input-pin-relative-y() -> length;
    pure callback compute-filter-data-output-pin-relative-x() -> length;
    pure callback compute-filter-data-output-pin-relative-y() -> length;
    pure callback compute-filter-control-input-pin-relative-x() -> length;
    pure callback compute-filter-control-input-pin-relative-y() -> length;

    // Implement the callbacks using library NodeLayout functions
    compute-node-screen-x(world-x) => { return NodeLayout.screen-x(world-x, zoom, pan-x); }
    compute-node-screen-y(world-y) => { return NodeLayout.screen-y(world-y, zoom, pan-y); }
    compute-node-screen-width => { return NodeLayout.screen-width(zoom); }
    compute-node-screen-height => { return NodeLayout.screen-height(zoom); }

    compute-input-pin-x(world-x) => { return NodeLayout.input-pin-x(world-x, zoom, pan-x); }
    compute-input-pin-y(world-y) => { return NodeLayout.input-pin-y(world-y, zoom, pan-y); }
    compute-output-pin-x(world-x) => { return NodeLayout.output-pin-x(world-x, zoom, pan-x); }
    compute-output-pin-y(world-y) => { return NodeLayout.output-pin-y(world-y, zoom, pan-y); }

    // Relative offsets (unscaled, from node top-left)
    compute-input-pin-relative-x => { return NodeLayout.input-pin-relative-x(); }
    compute-input-pin-relative-y => { return NodeLayout.input-pin-relative-y(); }
    compute-output-pin-relative-x => { return NodeLayout.output-pin-relative-x(); }
    compute-output-pin-relative-y => { return NodeLayout.output-pin-relative-y(); }

    compute-filter-screen-width => { return FilterNodeConstants.base-width * zoom; }
    compute-filter-screen-height => { return FilterNodeConstants.base-height * zoom; }

    compute-filter-data-input-pin-x(world-x) => {
        return world-x * 1px * zoom + pan-x + (FilterNodeConstants.pin-margin + FilterNodeConstants.pin-size / 2) * zoom;
    }
    compute-filter-data-input-pin-y(world-y) => {
        return world-y * 1px * zoom + pan-y + (FilterNodeConstants.content-padding + FilterNodeConstants.title-height + FilterNodeConstants.content-padding + FilterNodeConstants.row-height / 2) * zoom;
    }
    compute-filter-data-output-pin-x(world-x) => {
        return world-x * 1px * zoom + pan-x + (FilterNodeConstants.base-width - FilterNodeConstants.pin-margin - FilterNodeConstants.pin-size / 2) * zoom;
    }
    compute-filter-data-output-pin-y(world-y) => {
        return world-y * 1px * zoom + pan-y + (FilterNodeConstants.content-padding + FilterNodeConstants.title-height + FilterNodeConstants.content-padding + FilterNodeConstants.row-height / 2) * zoom;
    }
    compute-filter-control-input-pin-x(world-x) => {
        return world-x * 1px * zoom + pan-x + (FilterNodeConstants.pin-margin + FilterNodeConstants.pin-size / 2) * zoom;
    }
    compute-filter-control-input-pin-y(world-y) => {
        return world-y * 1px * zoom + pan-y + (FilterNodeConstants.content-padding + FilterNodeConstants.title-height + FilterNodeConstants.content-padding + FilterNodeConstants.row-height + FilterNodeConstants.row-height / 2) * zoom;
    }

    // Filter node relative offsets (unscaled, from node top-left)
    compute-filter-data-input-pin-relative-x => {
        return FilterNodeConstants.pin-margin + FilterNodeConstants.pin-size / 2;
    }
    compute-filter-data-input-pin-relative-y => {
        return FilterNodeConstants.content-padding + FilterNodeConstants.title-height + FilterNodeConstants.content-padding + FilterNodeConstants.row-height / 2;
    }
    compute-filter-data-output-pin-relative-x => {
        return FilterNodeConstants.base-width - FilterNodeConstants.pin-margin - FilterNodeConstants.pin-size / 2;
    }
    compute-filter-data-output-pin-relative-y => {
        return FilterNodeConstants.content-padding + FilterNodeConstants.title-height + FilterNodeConstants.content-padding + FilterNodeConstants.row-height / 2;
    }
    compute-filter-control-input-pin-relative-x => {
        return FilterNodeConstants.pin-margin + FilterNodeConstants.pin-size / 2;
    }
    compute-filter-control-input-pin-relative-y => {
        return FilterNodeConstants.content-padding + FilterNodeConstants.title-height + FilterNodeConstants.content-padding + FilterNodeConstants.row-height + FilterNodeConstants.row-height / 2;
    }

    // The composite NodeEditor handles all three layers:
    // 1. Background with grid
    // 2. Children (nodes and links) - placed via @children
    // 3. Overlay for input handling
    // Plus selection box and link preview rendering
    editor := NodeEditor {
        width: 100%;
        height: 100%;
        pan-x <=> root.pan-x;
        pan-y <=> root.pan-y;
        zoom <=> root.zoom;
        min-zoom: 0.25;
        max-zoom: 4.0;
        background-color: #1a1a1a;
        grid-spacing: 24px;
        grid-snapping <=> grid-snap-enabled;  // Bind to toggle
        grid-color: #333333;

        links: root.links;

        // Set pin hit radius from globals (eliminates hardcoded default in core)
        pin-hit-radius: NodeConstants.pin-size * zoom * 0.66;

        // Forward selection checking callbacks to editor
        is-selected(node-id) => { return root.is-node-selected(node-id); }
        is-link-selected(link-id) => { return root.is-link-selected(link-id); }

        // Drag state is now managed internally by NodeEditor

        link-requested => {
            // Request link creation - validation happens in application
            root.create-link(editor.requested-link-start-pin, editor.requested-link-end-pin);
        }

        context-menu-requested => {
            debug("Context menu at: " + editor.context-menu-x / 1px + ", " + editor.context-menu-y / 1px);
        }

        selection-changed => {
            // Editor has computed intersecting node IDs and updated selection - notify Rust
            root.selection-changed(editor.current-selected-ids);
        }

        node-drag-ended(delta-x, delta-y) => {
            // Editor has applied snapping - just commit to model
            root.commit-drag(delta-x, delta-y);
        }

        viewport-changed => {
            // Update link positions when pan or zoom changes
            root.update-viewport(zoom, pan-x / 1px, pan-y / 1px);
        }

        delete-selected => {
            // Delete selected nodes and links
            root.delete-selected-nodes();
            root.delete-selected-links();
        }

        add-node-requested => {
            // Add a new node
            root.add-node();
        }

        link-positions-changed => {
            // Editor has updated link positions - notify Rust to sync
            root.link-positions-updated();
        }

        // Links - children of NodeEditor (RENDERED FIRST so they appear BELOW nodes)
        // Uses core-generated bezier paths directly from model property
        for link-path in editor.link-paths: Link {
            path-commands: link-path.path-commands;
            // Highlight link when selected (cyan) or hovered (white)
            link-color: editor.is-link-selected(link-path.id) ? #00ffff :
                        link-path.id == hovered-link-id ? #ffffff : link-path.color;
            line-width: editor.is-link-selected(link-path.id) ? 4px * zoom :
                        link-path.id == hovered-link-id ? 4px * zoom : 3px * zoom;
        }

        // Nodes - children of NodeEditor
        // Selection state comes from editor via is-selected callback
        for node-data in nodes: Node {
            title: node-data.title;
            node-id: node-data.id;
            selected: editor.is-selected(node-data.id);
            world-x: node-data.world-x * 1px;
            world-y: node-data.world-y * 1px;
            // Drag offset is managed by editor and applied to selected nodes automatically
            drag-offset-x: editor.is-selected(node-data.id) ? editor.drag-offset-x : 0px;
            drag-offset-y: editor.is-selected(node-data.id) ? editor.drag-offset-y : 0px;
            zoom: zoom;
            pan-x: pan-x;
            pan-y: pan-y;
            clicked(id, shift) => {
                editor.clicked-node-id = id;
                editor.clicked-shift-held = shift;
                root.selection-changed(editor.current-selected-ids);
            }
            drag-started(id, already-selected) => {
                editor.start-node-drag(id, already-selected);
            }
            drag-moved(id, offset-x, offset-y) => {
                editor.update-node-drag(offset-x, offset-y);
            }
            drag-ended(id, delta-x, delta-y) => {
                editor.end-node-drag(delta-x, delta-y);
            }
            pin-position-changed(id, x, y) => {
                editor.reporting-pin-id = id;
                editor.reporting-pin-rel-x = x;
                editor.reporting-pin-rel-y = y;
                editor.pin-position-changed();
            }
            pin-drag-started(pin-id, x, y) => {
                // Start link creation using editor's state machine
                editor.pending-link-pin-id = pin-id;
                editor.pending-link-x = x;
                editor.pending-link-y = y;
                editor.start-link();  // Trigger editor to start link creation
            }
            pin-drag-moved(pin-id, x, y) => {
                // Update link preview end position via editor
                editor.link-end-x = x;
                editor.link-end-y = y;
            }
            pin-drag-ended(pin-id, x, y) => {
                // Complete link creation - editor will use find_pin_at() to find target
                editor.link-end-x = x;
                editor.link-end-y = y;
                editor.complete-link-creation = true;
                // Editor handles validation and fires link-created or link-dropped callback
            }
            report-rect(id, x, y, w, h) => {
                editor.reporting-node-id = id;
                editor.reporting-node-x = x;
                editor.reporting-node-y = y;
                editor.reporting-node-width = w;
                editor.reporting-node-height = h;
                editor.node-rect-changed();
            }
        }

        // Filter nodes - complex nodes with widgets (ComboBox, Buttons, etc.)
        for filter-data in filter-nodes: FilterNode {
            title: filter-data.title;
            node-id: filter-data.id;
            selected: editor.is-selected(filter-data.id);
            world-x: filter-data.world-x * 1px;
            world-y: filter-data.world-y * 1px;
            // Drag offset is managed by editor and applied to selected nodes automatically
            drag-offset-x: editor.is-selected(filter-data.id) ? editor.drag-offset-x : 0px;
            drag-offset-y: editor.is-selected(filter-data.id) ? editor.drag-offset-y : 0px;
            zoom: zoom;
            pan-x: pan-x;
            pan-y: pan-y;
            filter-type-index: filter-data.filter-type-index;
            enabled: filter-data.enabled;
            processed-count: filter-data.processed-count;

            clicked(id, shift) => {
                editor.clicked-node-id = id;
                editor.clicked-shift-held = shift;
                root.selection-changed(editor.current-selected-ids);
            }
            drag-started(id, already-selected) => {
                editor.start-node-drag(id, already-selected);
            }
            drag-moved(id, offset-x, offset-y) => {
                editor.update-node-drag(offset-x, offset-y);
            }
            drag-ended(id, delta-x, delta-y) => {
                editor.end-node-drag(delta-x, delta-y);
            }
            pin-position-changed(id, x, y) => {
                editor.reporting-pin-id = id;
                editor.reporting-pin-rel-x = x;
                editor.reporting-pin-rel-y = y;
                editor.pin-position-changed();
            }
            pin-drag-started(pin-id, x, y) => {
                editor.pending-link-pin-id = pin-id;
                editor.pending-link-x = x;
                editor.pending-link-y = y;
                editor.start-link();
            }
            pin-drag-moved(pin-id, x, y) => {
                editor.link-end-x = x;
                editor.link-end-y = y;
            }
            pin-drag-ended(pin-id, x, y) => {
                editor.link-end-x = x;
                editor.link-end-y = y;
                editor.complete-link-creation = true;
            }
            report-rect(id, x, y, w, h) => {
                editor.reporting-node-id = id;
                editor.reporting-node-x = x;
                editor.reporting-node-y = y;
                editor.reporting-node-width = w;
                editor.reporting-node-height = h;
                editor.node-rect-changed();
            }
            filter-type-changed(id, idx) => {
                root.filter-type-changed(id, idx);
            }
            toggle-enabled(id) => {
                root.filter-toggle-enabled(id);
            }
            reset-clicked(id) => {
                root.filter-reset(id);
            }
        }
    }

    // Instructions overlay
    InstructionsOverlay {
        grid-snap-enabled <=> grid-snap-enabled;
    }

    // Debug info
    Rectangle {
        x: parent.width - 160px;
        y: parent.height - 40px;
        width: 150px;
        height: 30px;
        background: #00000080;
        border-radius: 4px;

        Text {
            text: "Pins: " + editor.debug-pin-count;
            color: #aaa;
            font-size: 11px;
            horizontal-alignment: center;
            vertical-alignment: center;
        }
    }

    // Zoom indicator
    Rectangle {
        x: parent.width - 110px;
        y: 10px;
        width: 100px;
        height: 30px;
        background: #00000080;
        border-radius: 4px;

        Text {
            text: "Zoom: " + round(zoom * 100) + "%";
            color: white;
            horizontal-alignment: center;
            vertical-alignment: center;
        }
    }
}
