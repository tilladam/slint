// Node Editor Example
//
// This example demonstrates the NodeEditorBackground and NodeEditorOverlay
// native items for building visual node graph editors.
//
// Architecture (three-layer approach):
// 1. NodeEditorBackground - provides viewport properties (pan, zoom)
// 2. Node children - application-defined components (Node)
// 3. NodeEditorOverlay - handles input (pan, zoom, box selection)
//
// Rendering is done in Slint (not natively):
// - Grid: Path component with Rust-generated SVG commands
// - Links: Path components with bezier curves
// - Selection box: Rectangle bound to overlay's is-selecting/selection-* properties
// - Link preview: Path bound to local link-active/link-start-*/link-end-* properties
//
// Link creation flow (handled in Slint, not overlay):
// 1. Pin TouchArea starts drag -> sets local link-active, link-start-*, link-end-*
// 2. Link preview becomes visible (bound to link-active)
// 3. Pin TouchArea moves -> updates local link-end-x/y
// 4. Pin TouchArea releases -> computes target via find-pin-at(), validates, calls create-link
// 5. Rust's on_create_link callback adds the link to the model

// Data structure for nodes - exported to Rust
export struct NodeData {
    id: int,
    title: string,
    world-x: float,
    world-y: float,
    selected: bool,
}

// Data structure for links - exported to Rust
// Positions are computed by Rust and updated when nodes move or viewport changes
export struct LinkData {
    id: int,
    start-pin-id: int,
    end-pin-id: int,
    color: color,
    // Pre-computed screen positions (set by Rust)
    start-x: float,
    start-y: float,
    end-x: float,
    end-y: float,
}

// A bezier link between two pins
component Link inherits Path {
    in property <length> start-x;
    in property <length> start-y;
    in property <length> end-x;
    in property <length> end-y;
    in property <color> link-color: #888888;
    in property <length> line-width: 2px;
    in property <float> zoom: 1.0;

    // Calculate control point offset (horizontal bezier)
    property <length> dx: abs(end-x - start-x);
    property <length> offset: max(dx * 0.5, 50px * zoom);

    // Control points
    property <length> ctrl1-x: start-x + offset;
    property <length> ctrl1-y: start-y;
    property <length> ctrl2-x: end-x - offset;
    property <length> ctrl2-y: end-y;

    width: 100%;
    height: 100%;
    stroke: link-color;
    stroke-width: line-width;
    fill: transparent;

    // Set viewbox to match actual size so SVG coordinates map 1:1
    // Use max() to avoid zero-size viewbox during initial layout
    viewbox-x: 0;
    viewbox-y: 0;
    viewbox-width: max(self.width / 1px, 1);
    viewbox-height: max(self.height / 1px, 1);

    // SVG path command: M (move to), C (cubic bezier)
    commands: "M " + start-x / 1px + " " + start-y / 1px +
              " C " + ctrl1-x / 1px + " " + ctrl1-y / 1px +
              " " + ctrl2-x / 1px + " " + ctrl2-y / 1px +
              " " + end-x / 1px + " " + end-y / 1px;
}

// A basic node component with interactive pins
component Node inherits Rectangle {
    in property <string> title: "Node";
    in property <int> node-id;
    in property <int> input-pin-id: node-id * 10 + 1;   // e.g., node 1 -> pin 11
    in property <int> output-pin-id: node-id * 10 + 2;  // e.g., node 1 -> pin 12

    // Selection state
    in property <bool> selected: false;

    // World coordinates (grid space) - base position from model
    in property <length> world-x;
    in property <length> world-y;

    // Transform parameters (from parent)
    in property <float> zoom: 1.0;
    in property <length> pan-x: 0px;
    in property <length> pan-y: 0px;

    // External drag offset (for multi-select: all selected nodes get same offset)
    in property <length> drag-offset-x: 0px;
    in property <length> drag-offset-y: 0px;

    // Callbacks for pin drag-to-link (pin-id, x, y)
    callback pin-drag-started(int, length, length);
    callback pin-drag-moved(int, length, length);
    callback pin-drag-ended(int, length, length);

    // Callback when node is clicked (for selection) - passes node-id and shift-held
    callback clicked(int, bool);

    // Callbacks for node dragging (for multi-select support)
    callback drag-started(int);
    callback drag-moved(int, length, length);  // node-id, offset-x, offset-y
    callback drag-ended(int, length, length);  // node-id, delta-x, delta-y

    // Pin dimensions (scaled by zoom)
    property <length> base-pin-size: 12px;
    property <length> pin-size: base-pin-size * zoom;
    property <length> pin-radius: pin-size / 2;

    // Base dimensions
    property <length> base-width: 150px;
    property <length> base-height: 80px;

    // Screen position calculated from world position + drag offset
    property <length> screen-x: (world-x + drag-offset-x) * zoom + pan-x;
    property <length> screen-y: (world-y + drag-offset-y) * zoom + pan-y;

    // Expose pin positions (center of pin circles, in parent coordinates)
    out property <length> input-pin-x: screen-x + input-pin.x + pin-radius;
    out property <length> input-pin-y: screen-y + input-pin.y + pin-radius;
    out property <length> output-pin-x: screen-x + output-pin.x + pin-radius;
    out property <length> output-pin-y: screen-y + output-pin.y + pin-radius;

    x: screen-x;
    y: screen-y;
    width: base-width * zoom;
    height: base-height * zoom;
    background: selected ? #3a3a4a : #2d2d2d;
    border-radius: 8px * zoom;
    border-width: selected ? 2px * zoom : 1px * zoom;
    border-color: selected ? #4a9eff : #555;

    // Title bar
    Rectangle {
        x: 8px * zoom;
        y: 8px * zoom;
        width: parent.width - 16px * zoom;
        height: 24px * zoom;
        background: selected ? #4a6a9a : #3d3d3d;
        border-radius: 4px * zoom;

        Text {
            text: title;
            color: white;
            font-size: 14px * zoom;
            horizontal-alignment: center;
            vertical-alignment: center;
        }
    }

    // Drag handling for the node body (must be before pins so pins are on top)
    TouchArea {
        property <bool> shift-held: false;
        property <bool> was-dragged: false;
        property <length> drag-threshold: 5px;

        pointer-event(event) => {
            if event.kind == PointerEventKind.down && event.button == PointerEventButton.left {
                shift-held = event.modifiers.shift;
                was-dragged = false;
            }
            if event.kind == PointerEventKind.up && event.button == PointerEventButton.left {
                if !was-dragged {
                    root.clicked(node-id, shift-held);
                } else {
                    // Drag ended - report final delta (parent will reset offset)
                    root.drag-ended(node-id,
                        (self.mouse-x - self.pressed-x) / zoom,
                        (self.mouse-y - self.pressed-y) / zoom);
                }
            }
        }
        moved => {
            if self.pressed {
                // Check threshold
                if !was-dragged {
                    if self.mouse-x - self.pressed-x > drag-threshold ||
                       self.pressed-x - self.mouse-x > drag-threshold ||
                       self.mouse-y - self.pressed-y > drag-threshold ||
                       self.pressed-y - self.mouse-y > drag-threshold {
                        was-dragged = true;
                        root.drag-started(node-id);
                    }
                }

                // Report offset to parent (mouse-x - pressed-x is stable)
                if was-dragged {
                    root.drag-moved(node-id,
                        (self.mouse-x - self.pressed-x) / zoom,
                        (self.mouse-y - self.pressed-y) / zoom);
                }
            }
        }
    }

    // Input pin (green) - with drag-to-link support (on top of body TouchArea)
    input-pin := Rectangle {
        x: 8px * zoom;
        y: (8px + 24px + 8px) * zoom;  // below title bar
        width: pin-size;
        height: pin-size;
        background: input-pin-touch.has-hover ? #66BB6A : #4CAF50;
        border-radius: pin-radius;

        input-pin-touch := TouchArea {
            property <bool> drag-active: false;

            pointer-event(event) => {
                if event.kind == PointerEventKind.down && event.button == PointerEventButton.left {
                    drag-active = true;
                    pin-drag-started(input-pin-id, input-pin-x, input-pin-y);
                }
                if event.kind == PointerEventKind.up && drag-active {
                    drag-active = false;
                    // Calculate position in parent (window) coordinates
                    pin-drag-ended(input-pin-id, input-pin-x + self.mouse-x - pin-radius, input-pin-y + self.mouse-y - pin-radius);
                }
            }
            moved => {
                if drag-active {
                    // Calculate position in parent (window) coordinates
                    pin-drag-moved(input-pin-id, input-pin-x + self.mouse-x - pin-radius, input-pin-y + self.mouse-y - pin-radius);
                }
            }
        }
    }

    // Output pin (blue) - with drag-to-link support (on top of body TouchArea)
    output-pin := Rectangle {
        x: parent.width - 8px * zoom - pin-size;
        y: (8px + 24px + 8px) * zoom;  // below title bar
        width: pin-size;
        height: pin-size;
        background: output-pin-touch.has-hover ? #42A5F5 : #2196F3;
        border-radius: pin-radius;

        output-pin-touch := TouchArea {
            property <bool> drag-active: false;

            pointer-event(event) => {
                if event.kind == PointerEventKind.down && event.button == PointerEventButton.left {
                    drag-active = true;
                    pin-drag-started(output-pin-id, output-pin-x, output-pin-y);
                }
                if event.kind == PointerEventKind.up && drag-active {
                    drag-active = false;
                    // Calculate position in parent (window) coordinates
                    pin-drag-ended(output-pin-id, output-pin-x + self.mouse-x - pin-radius, output-pin-y + self.mouse-y - pin-radius);
                }
            }
            moved => {
                if drag-active {
                    // Calculate position in parent (window) coordinates
                    pin-drag-moved(output-pin-id, output-pin-x + self.mouse-x - pin-radius, output-pin-y + self.mouse-y - pin-radius);
                }
            }
        }
    }

}

export component MainWindow inherits Window {
    title: "Node Editor Example";
    width: 1200px;
    height: 800px;
    background: #1a1a1a;

    // Node model - owned by Rust
    in property <[NodeData]> nodes;

    // Link model - owned by Rust
    in property <[LinkData]> links;

    // Callbacks to Rust for state changes
    callback select-node(int, bool);  // node-id, shift-held
    callback commit-drag(float, float, bool);  // delta-world-x, delta-world-y, snap-to-grid
    callback update-viewport(float, float, float);  // zoom, pan-x, pan-y (for link position updates)
    callback create-link(int, int);  // start-pin-id, end-pin-id
    callback delete-selected-nodes();  // delete all selected nodes
    callback add-node();  // add a new node

    // Grid snap setting
    in-out property <bool> grid-snap-enabled: true;

    // Visual drag offset (tracked in Slint, not affecting model until drag ends)
    property <bool> is-dragging: false;
    property <length> visual-drag-offset-x: 0px;
    property <length> visual-drag-offset-y: 0px;

    // Shared pan state (in-out so Rust can read them)
    in-out property <length> pan-x: 0px;
    in-out property <length> pan-y: 0px;
    in-out property <float> zoom: 1.0;

    // Node dimensions (must match Node component)
    property <length> node-base-width: 150px;
    property <length> node-base-height: 80px;
    property <length> base-pin-size: 12px;
    property <length> pin-size: base-pin-size * zoom;
    property <length> pin-radius: pin-size / 2;

    // Compute pin positions from node world coordinates
    // Input pin: left side, below title bar
    pure function compute-input-pin-x(world-x: float) -> length {
        return world-x * 1px * zoom + pan-x + 8px * zoom + pin-radius;
    }
    pure function compute-input-pin-y(world-y: float) -> length {
        return world-y * 1px * zoom + pan-y + (8px + 24px + 8px) * zoom + pin-radius;
    }
    // Output pin: right side, below title bar
    pure function compute-output-pin-x(world-x: float) -> length {
        return world-x * 1px * zoom + pan-x + node-base-width * zoom - 8px * zoom - pin-size + pin-radius;
    }
    pure function compute-output-pin-y(world-y: float) -> length {
        return world-y * 1px * zoom + pan-y + (8px + 24px + 8px) * zoom + pin-radius;
    }

    // Get node world position from model by ID (includes visual drag offset if dragging)
    // Note: Slint doesn't support computed array indexing or loops in pure functions,
    // so we check each index explicitly and return when we find a match.
    // This supports up to 16 nodes.
    pure function get-node-world-x(node-id: int) -> float {
        if nodes.length > 0 && nodes[0].id == node-id {
            return nodes[0].world-x + (nodes[0].selected && is-dragging ? visual-drag-offset-x / 1px : 0);
        }
        if nodes.length > 1 && nodes[1].id == node-id {
            return nodes[1].world-x + (nodes[1].selected && is-dragging ? visual-drag-offset-x / 1px : 0);
        }
        if nodes.length > 2 && nodes[2].id == node-id {
            return nodes[2].world-x + (nodes[2].selected && is-dragging ? visual-drag-offset-x / 1px : 0);
        }
        if nodes.length > 3 && nodes[3].id == node-id {
            return nodes[3].world-x + (nodes[3].selected && is-dragging ? visual-drag-offset-x / 1px : 0);
        }
        if nodes.length > 4 && nodes[4].id == node-id {
            return nodes[4].world-x + (nodes[4].selected && is-dragging ? visual-drag-offset-x / 1px : 0);
        }
        if nodes.length > 5 && nodes[5].id == node-id {
            return nodes[5].world-x + (nodes[5].selected && is-dragging ? visual-drag-offset-x / 1px : 0);
        }
        if nodes.length > 6 && nodes[6].id == node-id {
            return nodes[6].world-x + (nodes[6].selected && is-dragging ? visual-drag-offset-x / 1px : 0);
        }
        if nodes.length > 7 && nodes[7].id == node-id {
            return nodes[7].world-x + (nodes[7].selected && is-dragging ? visual-drag-offset-x / 1px : 0);
        }
        if nodes.length > 8 && nodes[8].id == node-id {
            return nodes[8].world-x + (nodes[8].selected && is-dragging ? visual-drag-offset-x / 1px : 0);
        }
        if nodes.length > 9 && nodes[9].id == node-id {
            return nodes[9].world-x + (nodes[9].selected && is-dragging ? visual-drag-offset-x / 1px : 0);
        }
        if nodes.length > 10 && nodes[10].id == node-id {
            return nodes[10].world-x + (nodes[10].selected && is-dragging ? visual-drag-offset-x / 1px : 0);
        }
        if nodes.length > 11 && nodes[11].id == node-id {
            return nodes[11].world-x + (nodes[11].selected && is-dragging ? visual-drag-offset-x / 1px : 0);
        }
        if nodes.length > 12 && nodes[12].id == node-id {
            return nodes[12].world-x + (nodes[12].selected && is-dragging ? visual-drag-offset-x / 1px : 0);
        }
        if nodes.length > 13 && nodes[13].id == node-id {
            return nodes[13].world-x + (nodes[13].selected && is-dragging ? visual-drag-offset-x / 1px : 0);
        }
        if nodes.length > 14 && nodes[14].id == node-id {
            return nodes[14].world-x + (nodes[14].selected && is-dragging ? visual-drag-offset-x / 1px : 0);
        }
        if nodes.length > 15 && nodes[15].id == node-id {
            return nodes[15].world-x + (nodes[15].selected && is-dragging ? visual-drag-offset-x / 1px : 0);
        }
        return 0;
    }
    pure function get-node-world-y(node-id: int) -> float {
        if nodes.length > 0 && nodes[0].id == node-id {
            return nodes[0].world-y + (nodes[0].selected && is-dragging ? visual-drag-offset-y / 1px : 0);
        }
        if nodes.length > 1 && nodes[1].id == node-id {
            return nodes[1].world-y + (nodes[1].selected && is-dragging ? visual-drag-offset-y / 1px : 0);
        }
        if nodes.length > 2 && nodes[2].id == node-id {
            return nodes[2].world-y + (nodes[2].selected && is-dragging ? visual-drag-offset-y / 1px : 0);
        }
        if nodes.length > 3 && nodes[3].id == node-id {
            return nodes[3].world-y + (nodes[3].selected && is-dragging ? visual-drag-offset-y / 1px : 0);
        }
        if nodes.length > 4 && nodes[4].id == node-id {
            return nodes[4].world-y + (nodes[4].selected && is-dragging ? visual-drag-offset-y / 1px : 0);
        }
        if nodes.length > 5 && nodes[5].id == node-id {
            return nodes[5].world-y + (nodes[5].selected && is-dragging ? visual-drag-offset-y / 1px : 0);
        }
        if nodes.length > 6 && nodes[6].id == node-id {
            return nodes[6].world-y + (nodes[6].selected && is-dragging ? visual-drag-offset-y / 1px : 0);
        }
        if nodes.length > 7 && nodes[7].id == node-id {
            return nodes[7].world-y + (nodes[7].selected && is-dragging ? visual-drag-offset-y / 1px : 0);
        }
        if nodes.length > 8 && nodes[8].id == node-id {
            return nodes[8].world-y + (nodes[8].selected && is-dragging ? visual-drag-offset-y / 1px : 0);
        }
        if nodes.length > 9 && nodes[9].id == node-id {
            return nodes[9].world-y + (nodes[9].selected && is-dragging ? visual-drag-offset-y / 1px : 0);
        }
        if nodes.length > 10 && nodes[10].id == node-id {
            return nodes[10].world-y + (nodes[10].selected && is-dragging ? visual-drag-offset-y / 1px : 0);
        }
        if nodes.length > 11 && nodes[11].id == node-id {
            return nodes[11].world-y + (nodes[11].selected && is-dragging ? visual-drag-offset-y / 1px : 0);
        }
        if nodes.length > 12 && nodes[12].id == node-id {
            return nodes[12].world-y + (nodes[12].selected && is-dragging ? visual-drag-offset-y / 1px : 0);
        }
        if nodes.length > 13 && nodes[13].id == node-id {
            return nodes[13].world-y + (nodes[13].selected && is-dragging ? visual-drag-offset-y / 1px : 0);
        }
        if nodes.length > 14 && nodes[14].id == node-id {
            return nodes[14].world-y + (nodes[14].selected && is-dragging ? visual-drag-offset-y / 1px : 0);
        }
        if nodes.length > 15 && nodes[15].id == node-id {
            return nodes[15].world-y + (nodes[15].selected && is-dragging ? visual-drag-offset-y / 1px : 0);
        }
        return 0;
    }

    // The three-layer node editor structure
    // Background layer with grid (NodeEditorBackground generates grid-commands, Path renders them)
    background-layer := NodeEditorBackground {
        width: 100%;
        height: 100%;
        background-color: #1a1a1a;
        grid-spacing: 24px;
        grid-color: #333333;
        zoom: zoom;
        pan-x <=> pan-x;
        pan-y <=> pan-y;

        // Background fill
        Rectangle {
            width: 100%;
            height: 100%;
            background: parent.background-color;
        }

        // Grid rendered as Path, bound to generated commands from NodeEditorBackground
        Path {
            width: 100%;
            height: 100%;
            stroke: parent.grid-color;
            stroke-width: 1px;
            fill: transparent;
            viewbox-x: 0;
            viewbox-y: 0;
            viewbox-width: max(self.width / 1px, 1);
            viewbox-height: max(self.height / 1px, 1);
            commands: parent.grid-commands;
        }
    }

    // Callback for box selection - Rust handles the actual selection
    // Parameters: sel-x, sel-y, sel-width, sel-height, zoom, pan-x, pan-y
    callback box-select(length, length, length, length, float, length, length);

    // Link creation state managed directly in Slint
    property <bool> link-active: false;
    property <int> link-pin-id: 0;
    property <length> link-start-x: 0px;
    property <length> link-start-y: 0px;
    property <length> link-end-x: 0px;
    property <length> link-end-y: 0px;

    // Hit radius for pin detection (in screen pixels, scales with zoom)
    property <length> pin-hit-radius: 15px * zoom;

    // Helper: check if point is near a pin (returns pin-id or 0)
    pure function point-near-pin(x: length, y: length, pin-x: length, pin-y: length, pin-id: int) -> int {
        if (x - pin-x) * (x - pin-x) + (y - pin-y) * (y - pin-y) < pin-hit-radius * pin-hit-radius {
            return pin-id;
        }
        return 0;
    }

    // Helper: check if pin is an input pin (pin-id ends in 1)
    pure function is-input-pin(pin-id: int) -> bool {
        return mod(pin-id, 10) == 1;
    }

    // Helper: check if pin is an output pin (pin-id ends in 2)
    pure function is-output-pin(pin-id: int) -> bool {
        return mod(pin-id, 10) == 2;
    }

    // Helper: check if a node (given its ID) is selected
    pure function is-node-selected(node-id: int) -> bool {
        if nodes.length > 0 && nodes[0].id == node-id { return nodes[0].selected; }
        if nodes.length > 1 && nodes[1].id == node-id { return nodes[1].selected; }
        if nodes.length > 2 && nodes[2].id == node-id { return nodes[2].selected; }
        if nodes.length > 3 && nodes[3].id == node-id { return nodes[3].selected; }
        if nodes.length > 4 && nodes[4].id == node-id { return nodes[4].selected; }
        if nodes.length > 5 && nodes[5].id == node-id { return nodes[5].selected; }
        if nodes.length > 6 && nodes[6].id == node-id { return nodes[6].selected; }
        if nodes.length > 7 && nodes[7].id == node-id { return nodes[7].selected; }
        if nodes.length > 8 && nodes[8].id == node-id { return nodes[8].selected; }
        if nodes.length > 9 && nodes[9].id == node-id { return nodes[9].selected; }
        if nodes.length > 10 && nodes[10].id == node-id { return nodes[10].selected; }
        if nodes.length > 11 && nodes[11].id == node-id { return nodes[11].selected; }
        if nodes.length > 12 && nodes[12].id == node-id { return nodes[12].selected; }
        if nodes.length > 13 && nodes[13].id == node-id { return nodes[13].selected; }
        if nodes.length > 14 && nodes[14].id == node-id { return nodes[14].selected; }
        if nodes.length > 15 && nodes[15].id == node-id { return nodes[15].selected; }
        return false;
    }

    // Helper: get drag offset for a link endpoint during dragging
    // Returns the visual drag offset if the pin's node is selected and being dragged
    pure function get-link-drag-offset-x(pin-id: int) -> length {
        if !is-dragging { return 0px; }
        return is-node-selected(floor(pin-id / 10)) ? visual-drag-offset-x : 0px;
    }
    pure function get-link-drag-offset-y(pin-id: int) -> length {
        if !is-dragging { return 0px; }
        return is-node-selected(floor(pin-id / 10)) ? visual-drag-offset-y : 0px;
    }

    // Helper: get pin position by id (computed from model data)
    // Pin ID format: node_id * 10 + pin_type (1=input, 2=output)
    pure function get-pin-x(pin-id: int) -> length {
        // Extract node-id: pin-id / 10
        if mod(pin-id, 10) == 1 {
            // Input pin
            return compute-input-pin-x(get-node-world-x(floor(pin-id / 10)));
        } else {
            // Output pin
            return compute-output-pin-x(get-node-world-x(floor(pin-id / 10)));
        }
    }

    pure function get-pin-y(pin-id: int) -> length {
        if mod(pin-id, 10) == 1 {
            // Input pin
            return compute-input-pin-y(get-node-world-y(floor(pin-id / 10)));
        } else {
            // Output pin
            return compute-output-pin-y(get-node-world-y(floor(pin-id / 10)));
        }
    }

    // Find which pin (if any) is at position (uses computed positions from model)
    // Checks both input and output pins for each node in the model
    pure function find-pin-at(x: length, y: length) -> int {
        // Check pins for each node - input pin = node_id * 10 + 1, output pin = node_id * 10 + 2
        if nodes.length > 0 {
            if point-near-pin(x, y, get-pin-x(nodes[0].id * 10 + 1), get-pin-y(nodes[0].id * 10 + 1), nodes[0].id * 10 + 1) != 0 { return nodes[0].id * 10 + 1; }
            if point-near-pin(x, y, get-pin-x(nodes[0].id * 10 + 2), get-pin-y(nodes[0].id * 10 + 2), nodes[0].id * 10 + 2) != 0 { return nodes[0].id * 10 + 2; }
        }
        if nodes.length > 1 {
            if point-near-pin(x, y, get-pin-x(nodes[1].id * 10 + 1), get-pin-y(nodes[1].id * 10 + 1), nodes[1].id * 10 + 1) != 0 { return nodes[1].id * 10 + 1; }
            if point-near-pin(x, y, get-pin-x(nodes[1].id * 10 + 2), get-pin-y(nodes[1].id * 10 + 2), nodes[1].id * 10 + 2) != 0 { return nodes[1].id * 10 + 2; }
        }
        if nodes.length > 2 {
            if point-near-pin(x, y, get-pin-x(nodes[2].id * 10 + 1), get-pin-y(nodes[2].id * 10 + 1), nodes[2].id * 10 + 1) != 0 { return nodes[2].id * 10 + 1; }
            if point-near-pin(x, y, get-pin-x(nodes[2].id * 10 + 2), get-pin-y(nodes[2].id * 10 + 2), nodes[2].id * 10 + 2) != 0 { return nodes[2].id * 10 + 2; }
        }
        if nodes.length > 3 {
            if point-near-pin(x, y, get-pin-x(nodes[3].id * 10 + 1), get-pin-y(nodes[3].id * 10 + 1), nodes[3].id * 10 + 1) != 0 { return nodes[3].id * 10 + 1; }
            if point-near-pin(x, y, get-pin-x(nodes[3].id * 10 + 2), get-pin-y(nodes[3].id * 10 + 2), nodes[3].id * 10 + 2) != 0 { return nodes[3].id * 10 + 2; }
        }
        if nodes.length > 4 {
            if point-near-pin(x, y, get-pin-x(nodes[4].id * 10 + 1), get-pin-y(nodes[4].id * 10 + 1), nodes[4].id * 10 + 1) != 0 { return nodes[4].id * 10 + 1; }
            if point-near-pin(x, y, get-pin-x(nodes[4].id * 10 + 2), get-pin-y(nodes[4].id * 10 + 2), nodes[4].id * 10 + 2) != 0 { return nodes[4].id * 10 + 2; }
        }
        if nodes.length > 5 {
            if point-near-pin(x, y, get-pin-x(nodes[5].id * 10 + 1), get-pin-y(nodes[5].id * 10 + 1), nodes[5].id * 10 + 1) != 0 { return nodes[5].id * 10 + 1; }
            if point-near-pin(x, y, get-pin-x(nodes[5].id * 10 + 2), get-pin-y(nodes[5].id * 10 + 2), nodes[5].id * 10 + 2) != 0 { return nodes[5].id * 10 + 2; }
        }
        if nodes.length > 6 {
            if point-near-pin(x, y, get-pin-x(nodes[6].id * 10 + 1), get-pin-y(nodes[6].id * 10 + 1), nodes[6].id * 10 + 1) != 0 { return nodes[6].id * 10 + 1; }
            if point-near-pin(x, y, get-pin-x(nodes[6].id * 10 + 2), get-pin-y(nodes[6].id * 10 + 2), nodes[6].id * 10 + 2) != 0 { return nodes[6].id * 10 + 2; }
        }
        if nodes.length > 7 {
            if point-near-pin(x, y, get-pin-x(nodes[7].id * 10 + 1), get-pin-y(nodes[7].id * 10 + 1), nodes[7].id * 10 + 1) != 0 { return nodes[7].id * 10 + 1; }
            if point-near-pin(x, y, get-pin-x(nodes[7].id * 10 + 2), get-pin-y(nodes[7].id * 10 + 2), nodes[7].id * 10 + 2) != 0 { return nodes[7].id * 10 + 2; }
        }
        if nodes.length > 8 {
            if point-near-pin(x, y, get-pin-x(nodes[8].id * 10 + 1), get-pin-y(nodes[8].id * 10 + 1), nodes[8].id * 10 + 1) != 0 { return nodes[8].id * 10 + 1; }
            if point-near-pin(x, y, get-pin-x(nodes[8].id * 10 + 2), get-pin-y(nodes[8].id * 10 + 2), nodes[8].id * 10 + 2) != 0 { return nodes[8].id * 10 + 2; }
        }
        if nodes.length > 9 {
            if point-near-pin(x, y, get-pin-x(nodes[9].id * 10 + 1), get-pin-y(nodes[9].id * 10 + 1), nodes[9].id * 10 + 1) != 0 { return nodes[9].id * 10 + 1; }
            if point-near-pin(x, y, get-pin-x(nodes[9].id * 10 + 2), get-pin-y(nodes[9].id * 10 + 2), nodes[9].id * 10 + 2) != 0 { return nodes[9].id * 10 + 2; }
        }
        if nodes.length > 10 {
            if point-near-pin(x, y, get-pin-x(nodes[10].id * 10 + 1), get-pin-y(nodes[10].id * 10 + 1), nodes[10].id * 10 + 1) != 0 { return nodes[10].id * 10 + 1; }
            if point-near-pin(x, y, get-pin-x(nodes[10].id * 10 + 2), get-pin-y(nodes[10].id * 10 + 2), nodes[10].id * 10 + 2) != 0 { return nodes[10].id * 10 + 2; }
        }
        if nodes.length > 11 {
            if point-near-pin(x, y, get-pin-x(nodes[11].id * 10 + 1), get-pin-y(nodes[11].id * 10 + 1), nodes[11].id * 10 + 1) != 0 { return nodes[11].id * 10 + 1; }
            if point-near-pin(x, y, get-pin-x(nodes[11].id * 10 + 2), get-pin-y(nodes[11].id * 10 + 2), nodes[11].id * 10 + 2) != 0 { return nodes[11].id * 10 + 2; }
        }
        if nodes.length > 12 {
            if point-near-pin(x, y, get-pin-x(nodes[12].id * 10 + 1), get-pin-y(nodes[12].id * 10 + 1), nodes[12].id * 10 + 1) != 0 { return nodes[12].id * 10 + 1; }
            if point-near-pin(x, y, get-pin-x(nodes[12].id * 10 + 2), get-pin-y(nodes[12].id * 10 + 2), nodes[12].id * 10 + 2) != 0 { return nodes[12].id * 10 + 2; }
        }
        if nodes.length > 13 {
            if point-near-pin(x, y, get-pin-x(nodes[13].id * 10 + 1), get-pin-y(nodes[13].id * 10 + 1), nodes[13].id * 10 + 1) != 0 { return nodes[13].id * 10 + 1; }
            if point-near-pin(x, y, get-pin-x(nodes[13].id * 10 + 2), get-pin-y(nodes[13].id * 10 + 2), nodes[13].id * 10 + 2) != 0 { return nodes[13].id * 10 + 2; }
        }
        if nodes.length > 14 {
            if point-near-pin(x, y, get-pin-x(nodes[14].id * 10 + 1), get-pin-y(nodes[14].id * 10 + 1), nodes[14].id * 10 + 1) != 0 { return nodes[14].id * 10 + 1; }
            if point-near-pin(x, y, get-pin-x(nodes[14].id * 10 + 2), get-pin-y(nodes[14].id * 10 + 2), nodes[14].id * 10 + 2) != 0 { return nodes[14].id * 10 + 2; }
        }
        if nodes.length > 15 {
            if point-near-pin(x, y, get-pin-x(nodes[15].id * 10 + 1), get-pin-y(nodes[15].id * 10 + 1), nodes[15].id * 10 + 1) != 0 { return nodes[15].id * 10 + 1; }
            if point-near-pin(x, y, get-pin-x(nodes[15].id * 10 + 2), get-pin-y(nodes[15].id * 10 + 2), nodes[15].id * 10 + 2) != 0 { return nodes[15].id * 10 + 2; }
        }
        return 0;
    }

    // Internal function to request link creation from Rust
    function request-link-creation(start-pin: int, end-pin: int) {
        root.create-link(start-pin, end-pin);
    }

    // Helper functions for link creation
    function start-link-creation(pin-id: int, x: length, y: length) {
        link-active = true;
        link-pin-id = pin-id;
        link-start-x = x;
        link-start-y = y;
        link-end-x = x;
        link-end-y = y;
    }

    function update-link-position(pin-id: int, x: length, y: length) {
        if link-active && link-pin-id == pin-id {
            link-end-x = x;
            link-end-y = y;
        }
    }

    // Temporary storage for hit-testing result
    property <int> drop-target-pin: 0;

    function end-link-creation(pin-id: int, x: length, y: length) {
        if link-active && link-pin-id == pin-id {
            // Check if we're dropping on a valid target pin
            drop-target-pin = find-pin-at(x, y);

            if drop-target-pin != 0 && drop-target-pin != pin-id {
                // Validate: output should connect to input (or vice versa)
                if (is-output-pin(pin-id) && is-input-pin(drop-target-pin)) ||
                   (is-input-pin(pin-id) && is-output-pin(drop-target-pin)) {
                    // Normalize: always store output -> input
                    if is-output-pin(pin-id) {
                        request-link-creation(pin-id, drop-target-pin);
                    } else {
                        request-link-creation(drop-target-pin, pin-id);
                    }
                }
            }

            link-active = false;
            link-pin-id = 0;
        }
    }

    // Nodes layer - iterate over model from Rust
    // During drag, apply visual offset. Model is only updated on drag-end.
    for node-data in nodes: Node {
        title: node-data.title;
        node-id: node-data.id;
        selected: node-data.selected;
        world-x: node-data.world-x * 1px;
        world-y: node-data.world-y * 1px;
        // Pass drag offset to selected nodes
        drag-offset-x: node-data.selected && is-dragging ? visual-drag-offset-x : 0px;
        drag-offset-y: node-data.selected && is-dragging ? visual-drag-offset-y : 0px;
        zoom: zoom;
        pan-x: pan-x;
        pan-y: pan-y;
        clicked(id, shift) => { root.select-node(id, shift); }
        drag-started(id) => {
            is-dragging = true;
            visual-drag-offset-x = 0px;
            visual-drag-offset-y = 0px;
        }
        drag-moved(id, offset-x, offset-y) => {
            // Update visual offset for all selected nodes
            visual-drag-offset-x = offset-x;
            visual-drag-offset-y = offset-y;
        }
        drag-ended(id, delta-x, delta-y) => {
            // Commit to model
            root.commit-drag(delta-x / 1px, delta-y / 1px, grid-snap-enabled);
            is-dragging = false;
            visual-drag-offset-x = 0px;
            visual-drag-offset-y = 0px;
        }
        pin-drag-started(pin-id, x, y) => {
            // Start link preview using local state (overlay doesn't receive events during pin drag)
            link-active = true;
            link-pin-id = pin-id;
            link-start-x = x;
            link-start-y = y;
            link-end-x = x;
            link-end-y = y;
        }
        pin-drag-moved(pin-id, x, y) => {
            // Update link preview end position
            link-end-x = x;
            link-end-y = y;
        }
        pin-drag-ended(pin-id, x, y) => {
            // End link preview
            link-active = false;
            // Check if dropped on a valid target pin and create link
            drop-target-pin = find-pin-at(x, y);
            if drop-target-pin != 0 && drop-target-pin != link-pin-id {
                // Validate: output should connect to input (or vice versa)
                if (is-output-pin(link-pin-id) && is-input-pin(drop-target-pin)) ||
                   (is-input-pin(link-pin-id) && is-output-pin(drop-target-pin)) {
                    // Normalize: always store output -> input
                    if is-output-pin(link-pin-id) {
                        root.create-link(link-pin-id, drop-target-pin);
                    } else {
                        root.create-link(drop-target-pin, link-pin-id);
                    }
                }
            }
            link-pin-id = 0;
        }
    }

    // Links layer (between nodes and overlay) - iterates over Rust-owned model
    for link-data in links: Link {
        // Use pre-computed positions from Rust, applying visual drag offset during dragging
        start-x: link-data.start-x * 1px + get-link-drag-offset-x(link-data.start-pin-id);
        start-y: link-data.start-y * 1px + get-link-drag-offset-y(link-data.start-pin-id);
        end-x: link-data.end-x * 1px + get-link-drag-offset-x(link-data.end-pin-id);
        end-y: link-data.end-y * 1px + get-link-drag-offset-y(link-data.end-pin-id);
        link-color: link-data.color;
        line-width: 3px * zoom;
        zoom: zoom;
    }

    // Overlay layer (on top)
    overlay := NodeEditorOverlay {
        width: 100%;
        height: 100%;
        pan-x <=> pan-x;
        pan-y <=> pan-y;
        zoom <=> zoom;
        min-zoom: 0.25;
        max-zoom: 4.0;

        link-created => {
            // Create link using the overlay's output properties
            root.create-link(overlay.created-link-start-pin, overlay.created-link-end-pin);
        }

        link-dropped => {
            debug("Link dropped on empty space");
        }

        context-menu-requested => {
            debug("Context menu at: " + overlay.context-menu-x / 1px + ", " + overlay.context-menu-y / 1px);
        }

        selection-changed => {
            // Send box selection info to Rust for processing
            if overlay.selection-width > 5px && overlay.selection-height > 5px {
                root.box-select(overlay.selection-x, overlay.selection-y,
                               overlay.selection-width, overlay.selection-height,
                               zoom, pan-x, pan-y);
            }
        }

        viewport-changed => {
            // Update link positions when pan or zoom changes (grid is handled by NodeEditorBackground)
            root.update-viewport(zoom, pan-x / 1px, pan-y / 1px);
        }

        delete-selected => {
            // Delete selected nodes
            root.delete-selected-nodes();
        }

        add-node-requested => {
            // Add a new node
            root.add-node();
        }
    }

    // Selection box (rendered based on overlay state)
    Rectangle {
        visible: overlay.is-selecting;
        x: overlay.selection-x;
        y: overlay.selection-y;
        width: overlay.selection-width;
        height: overlay.selection-height;
        background: #4488ff20;
        border-color: #4488ff;
        border-width: 1px;
    }

    // Active link preview (rendered during link creation, using local state)
    Link {
        visible: link-active;
        start-x: link-start-x;
        start-y: link-start-y;
        end-x: link-end-x;
        end-y: link-end-y;
        link-color: #ffffff80;
        line-width: 2px * zoom;
        zoom: zoom;
    }

    // Instructions overlay
    Rectangle {
        x: 10px;
        y: 10px;
        width: 280px;
        height: 200px;
        background: #00000080;
        border-radius: 8px;

        VerticalLayout {
            padding: 12px;
            spacing: 4px;

            Text { text: "Node Editor Controls:"; color: #fff; font-size: 14px; font-weight: 600; }
            Text { text: "Middle mouse: Pan"; color: #ccc; font-size: 12px; }
            Text { text: "Scroll wheel: Zoom"; color: #ccc; font-size: 12px; }
            Text { text: "Drag nodes to move them"; color: #ccc; font-size: 12px; }
            Text { text: "Drag from pin: Create link"; color: #ccc; font-size: 12px; }
            Text { text: "Ctrl+drag: Box select"; color: #ccc; font-size: 12px; }
            Text { text: "Shift+click: Extend selection"; color: #ccc; font-size: 12px; }

            Rectangle { height: 8px; } // Spacer

            HorizontalLayout {
                spacing: 8px;
                alignment: start;

                // Custom checkbox
                Rectangle {
                    width: 16px;
                    height: 16px;
                    border-radius: 3px;
                    border-width: 1px;
                    border-color: #888;
                    background: grid-snap-enabled ? #4a9eff : #333;

                    // Checkmark
                    Text {
                        text: grid-snap-enabled ? "âœ“" : "";
                        color: white;
                        font-size: 12px;
                        horizontal-alignment: center;
                        vertical-alignment: center;
                    }

                    TouchArea {
                        clicked => {
                            grid-snap-enabled = !grid-snap-enabled;
                        }
                    }
                }
                Text {
                    text: "Snap to grid";
                    color: #ccc;
                    font-size: 12px;
                    vertical-alignment: center;
                }
            }
        }
    }

    // Zoom indicator
    Rectangle {
        x: parent.width - 110px;
        y: 10px;
        width: 100px;
        height: 30px;
        background: #00000080;
        border-radius: 4px;

        Text {
            text: "Zoom: " + round(zoom * 100) + "%";
            color: white;
            horizontal-alignment: center;
            vertical-alignment: center;
        }
    }
}
