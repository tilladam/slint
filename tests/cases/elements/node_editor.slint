// Copyright © SixtyFPS GmbH <info@slint.dev>
// SPDX-License-Identifier: GPL-3.0-only OR LicenseRef-Slint-Royalty-free-2.0 OR LicenseRef-Slint-Software-3.0

// Tests for NodeEditorBackground and NodeEditorOverlay components

TestCase := Window {
    width: 800phx;
    height: 600phx;

    // Shared state
    property <length> pan-x: 0phx;
    property <length> pan-y: 0phx;
    property <float> zoom: 1.0;

    // Callback tracking (count only since callbacks are now void)
    property <int> link-created-count: 0;
    property <int> link-dropped-count: 0;
    property <int> link-cancelled-count: 0;
    property <int> context-menu-count: 0;
    property <int> selection-changed-count: 0;

    background := NodeEditorBackground {
        width: 100%;
        height: 100%;
        pan-x <=> root.pan-x;
        pan-y <=> root.pan-y;
        zoom: root.zoom;
        grid-spacing: 24px;
        grid-color: #333333;
        background-color: #1a1a1a;
    }

    overlay := NodeEditorOverlay {
        width: 100%;
        height: 100%;
        pan-x <=> root.pan-x;
        pan-y <=> root.pan-y;
        zoom <=> root.zoom;
        min-zoom: 0.25;
        max-zoom: 4.0;
        selection-box-color: #4488ff40;
        active-link-color: #ffffff;

        link-created => {
            root.link-created-count += 1;
        }

        link-dropped => {
            root.link-dropped-count += 1;
        }

        link-cancelled => {
            root.link-cancelled-count += 1;
        }

        context-menu-requested => {
            root.context-menu-count += 1;
        }

        selection-changed => {
            root.selection-changed-count += 1;
        }
    }

    // Expose properties for testing (in-out to allow setting from tests)
    in-out property <length> test-pan-x <=> pan-x;
    in-out property <length> test-pan-y <=> pan-y;
    in-out property <float> test-zoom <=> zoom;
    out property <length> bg-grid-spacing: background.grid-spacing;
    out property <color> bg-grid-color: background.grid-color;
    out property <int> test-link-cancelled-count: link-cancelled-count;
    out property <int> test-selection-changed-count: selection-changed-count;

    // Selection box properties
    out property <bool> test-is-selecting: overlay.is-selecting;
    out property <length> test-selection-x: overlay.selection-x;
    out property <length> test-selection-y: overlay.selection-y;
    out property <length> test-selection-width: overlay.selection-width;
    out property <length> test-selection-height: overlay.selection-height;

    // Context menu properties
    out property <length> test-context-menu-x: overlay.context-menu-x;
    out property <length> test-context-menu-y: overlay.context-menu-y;
}

/*

```rust
// Test: NodeEditorBackground default properties
let instance = TestCase::new().unwrap();

// Check default values
assert_eq!(instance.get_test_pan_x(), 0.0);
assert_eq!(instance.get_test_pan_y(), 0.0);
assert_eq!(instance.get_test_zoom(), 1.0);
assert_eq!(instance.get_bg_grid_spacing(), 24.0);
```

```rust
// Test: Middle mouse button panning
use slint::{platform::WindowEvent, platform::PointerEventButton, LogicalPosition};
let instance = TestCase::new().unwrap();

// Initial state
assert_eq!(instance.get_test_pan_x(), 0.0);
assert_eq!(instance.get_test_pan_y(), 0.0);

// Start panning with middle mouse button
instance.window().dispatch_event(WindowEvent::PointerMoved { position: LogicalPosition::new(400.0, 300.0) });
instance.window().dispatch_event(WindowEvent::PointerPressed { position: LogicalPosition::new(400.0, 300.0), button: PointerEventButton::Middle });

// Pan should not change yet (just pressed)
assert_eq!(instance.get_test_pan_x(), 0.0);
assert_eq!(instance.get_test_pan_y(), 0.0);

// Move mouse while middle button is pressed
instance.window().dispatch_event(WindowEvent::PointerMoved { position: LogicalPosition::new(500.0, 350.0) });

// Pan should update
assert_eq!(instance.get_test_pan_x(), 100.0);
assert_eq!(instance.get_test_pan_y(), 50.0);

// Continue moving
instance.window().dispatch_event(WindowEvent::PointerMoved { position: LogicalPosition::new(450.0, 400.0) });
assert_eq!(instance.get_test_pan_x(), 50.0);
assert_eq!(instance.get_test_pan_y(), 100.0);

// Release middle button
instance.window().dispatch_event(WindowEvent::PointerReleased { position: LogicalPosition::new(450.0, 400.0), button: PointerEventButton::Middle });

// Pan should stay at last position
assert_eq!(instance.get_test_pan_x(), 50.0);
assert_eq!(instance.get_test_pan_y(), 100.0);

// Moving after release should not change pan
instance.window().dispatch_event(WindowEvent::PointerMoved { position: LogicalPosition::new(200.0, 200.0) });
assert_eq!(instance.get_test_pan_x(), 50.0);
assert_eq!(instance.get_test_pan_y(), 100.0);
```

```rust
// Test: Scroll wheel zooming
use slint::{platform::WindowEvent, LogicalPosition};
let instance = TestCase::new().unwrap();

// Initial zoom
assert_eq!(instance.get_test_zoom(), 1.0);

// Scroll up to zoom in
instance.window().dispatch_event(WindowEvent::PointerScrolled {
    position: LogicalPosition::new(400.0, 300.0),
    delta_x: 0.0,
    delta_y: 1.0  // Positive = zoom in
});

// Zoom should increase (1.0 * 1.1 = 1.1)
let zoom_after_in = instance.get_test_zoom();
assert!(zoom_after_in > 1.0, "Zoom should increase: {}", zoom_after_in);
assert!((zoom_after_in - 1.1).abs() < 0.01, "Zoom should be ~1.1: {}", zoom_after_in);

// Scroll down to zoom out
instance.window().dispatch_event(WindowEvent::PointerScrolled {
    position: LogicalPosition::new(400.0, 300.0),
    delta_x: 0.0,
    delta_y: -1.0  // Negative = zoom out
});

// Zoom should decrease (1.1 * 0.9 ≈ 0.99)
let zoom_after_out = instance.get_test_zoom();
assert!(zoom_after_out < zoom_after_in, "Zoom should decrease");
assert!((zoom_after_out - 0.99).abs() < 0.02, "Zoom should be ~0.99: {}", zoom_after_out);
```

```rust
// Test: Zoom clamping to min/max
use slint::{platform::WindowEvent, LogicalPosition};
let instance = TestCase::new().unwrap();

// Zoom in repeatedly to hit max (4.0)
for _ in 0..50 {
    instance.window().dispatch_event(WindowEvent::PointerScrolled {
        position: LogicalPosition::new(400.0, 300.0),
        delta_x: 0.0,
        delta_y: 1.0
    });
}

let max_zoom = instance.get_test_zoom();
assert!(max_zoom <= 4.0, "Zoom should not exceed max: {}", max_zoom);
assert!(max_zoom >= 3.9, "Zoom should be near max: {}", max_zoom);

// Reset zoom
instance.set_test_zoom(1.0);

// Zoom out repeatedly to hit min (0.25)
for _ in 0..50 {
    instance.window().dispatch_event(WindowEvent::PointerScrolled {
        position: LogicalPosition::new(400.0, 300.0),
        delta_x: 0.0,
        delta_y: -1.0
    });
}

let min_zoom = instance.get_test_zoom();
assert!(min_zoom >= 0.25, "Zoom should not go below min: {}", min_zoom);
assert!(min_zoom <= 0.26, "Zoom should be near min: {}", min_zoom);
```

```rust
// Test: Right-click context menu callback
use slint::{platform::WindowEvent, platform::PointerEventButton, LogicalPosition};
let instance = TestCase::new().unwrap();

// Initial state
assert_eq!(instance.get_context_menu_count(), 0);

// Right-click to request context menu
instance.window().dispatch_event(WindowEvent::PointerMoved { position: LogicalPosition::new(250.0, 150.0) });
instance.window().dispatch_event(WindowEvent::PointerPressed { position: LogicalPosition::new(250.0, 150.0), button: PointerEventButton::Right });

// Context menu callback should have been called
assert_eq!(instance.get_context_menu_count(), 1);

// Release right button
instance.window().dispatch_event(WindowEvent::PointerReleased { position: LogicalPosition::new(250.0, 150.0), button: PointerEventButton::Right });

// Another right-click at different position
instance.window().dispatch_event(WindowEvent::PointerPressed { position: LogicalPosition::new(500.0, 400.0), button: PointerEventButton::Right });
assert_eq!(instance.get_context_menu_count(), 2);
```

```rust
// Test: Left-click passes through (allows node interaction)
use slint::{platform::WindowEvent, platform::PointerEventButton, LogicalPosition};
let instance = TestCase::new().unwrap();

// Left-click without Shift should pass through to nodes (not start box selection)
instance.window().dispatch_event(WindowEvent::PointerMoved { position: LogicalPosition::new(100.0, 100.0) });
instance.window().dispatch_event(WindowEvent::PointerPressed { position: LogicalPosition::new(100.0, 100.0), button: PointerEventButton::Left });

// Move mouse
instance.window().dispatch_event(WindowEvent::PointerMoved { position: LogicalPosition::new(300.0, 250.0) });

// Release
instance.window().dispatch_event(WindowEvent::PointerReleased { position: LogicalPosition::new(300.0, 250.0), button: PointerEventButton::Left });

// Pan should not have changed (left click passes through)
assert_eq!(instance.get_test_pan_x(), 0.0);
assert_eq!(instance.get_test_pan_y(), 0.0);
```

```rust
// Test: Ctrl+Left-click starts box selection
use slint::{platform::WindowEvent, platform::PointerEventButton, LogicalPosition, platform::Key};
let instance = TestCase::new().unwrap();

// Hold Ctrl
slint_testing::send_keyboard_char(&instance, Key::Control.into(), true);

// Ctrl+Left-click should start box selection
instance.window().dispatch_event(WindowEvent::PointerMoved { position: LogicalPosition::new(100.0, 100.0) });
instance.window().dispatch_event(WindowEvent::PointerPressed { position: LogicalPosition::new(100.0, 100.0), button: PointerEventButton::Left });

// Move to create selection box
instance.window().dispatch_event(WindowEvent::PointerMoved { position: LogicalPosition::new(300.0, 250.0) });

// Release to complete selection
instance.window().dispatch_event(WindowEvent::PointerReleased { position: LogicalPosition::new(300.0, 250.0), button: PointerEventButton::Left });

// Release Ctrl
slint_testing::send_keyboard_char(&instance, Key::Control.into(), false);

// Pan should not have changed
assert_eq!(instance.get_test_pan_x(), 0.0);
assert_eq!(instance.get_test_pan_y(), 0.0);
```

```rust
// Test: Zoom preserves position under mouse cursor
use slint::{platform::WindowEvent, LogicalPosition};
let instance = TestCase::new().unwrap();

// Set initial pan
instance.set_test_pan_x(100.0);
instance.set_test_pan_y(50.0);

let initial_pan_x = instance.get_test_pan_x();
let initial_pan_y = instance.get_test_pan_y();
let initial_zoom = instance.get_test_zoom();

// Zoom at center of window
let mouse_x = 400.0;
let mouse_y = 300.0;

// Calculate the graph point under the mouse before zoom
let graph_x_before = (mouse_x - initial_pan_x as f32) / initial_zoom;
let graph_y_before = (mouse_y - initial_pan_y as f32) / initial_zoom;

// Zoom in
instance.window().dispatch_event(WindowEvent::PointerScrolled {
    position: LogicalPosition::new(mouse_x, mouse_y),
    delta_x: 0.0,
    delta_y: 1.0
});

let new_pan_x = instance.get_test_pan_x();
let new_pan_y = instance.get_test_pan_y();
let new_zoom = instance.get_test_zoom();

// Calculate the graph point under the mouse after zoom
let graph_x_after = (mouse_x - new_pan_x as f32) / new_zoom;
let graph_y_after = (mouse_y - new_pan_y as f32) / new_zoom;

// The point under the mouse should be the same (within floating point tolerance)
assert!((graph_x_before - graph_x_after).abs() < 1.0,
    "Graph X should be preserved: before={}, after={}", graph_x_before, graph_x_after);
assert!((graph_y_before - graph_y_after).abs() < 1.0,
    "Graph Y should be preserved: before={}, after={}", graph_y_before, graph_y_after);
```

```rust
// Test: Multiple pan operations accumulate correctly
use slint::{platform::WindowEvent, platform::PointerEventButton, LogicalPosition};
let instance = TestCase::new().unwrap();

// First pan operation
instance.window().dispatch_event(WindowEvent::PointerPressed { position: LogicalPosition::new(400.0, 300.0), button: PointerEventButton::Middle });
instance.window().dispatch_event(WindowEvent::PointerMoved { position: LogicalPosition::new(450.0, 350.0) });
instance.window().dispatch_event(WindowEvent::PointerReleased { position: LogicalPosition::new(450.0, 350.0), button: PointerEventButton::Middle });

assert_eq!(instance.get_test_pan_x(), 50.0);
assert_eq!(instance.get_test_pan_y(), 50.0);

// Second pan operation should add to existing pan
instance.window().dispatch_event(WindowEvent::PointerPressed { position: LogicalPosition::new(200.0, 200.0), button: PointerEventButton::Middle });
instance.window().dispatch_event(WindowEvent::PointerMoved { position: LogicalPosition::new(300.0, 250.0) });
instance.window().dispatch_event(WindowEvent::PointerReleased { position: LogicalPosition::new(300.0, 250.0), button: PointerEventButton::Middle });

assert_eq!(instance.get_test_pan_x(), 150.0);
assert_eq!(instance.get_test_pan_y(), 100.0);
```

```rust
// Test: Mouse exit during panning cancels pan
use slint::{platform::WindowEvent, platform::PointerEventButton, LogicalPosition};
let instance = TestCase::new().unwrap();

// Start panning
instance.window().dispatch_event(WindowEvent::PointerMoved { position: LogicalPosition::new(400.0, 300.0) });
instance.window().dispatch_event(WindowEvent::PointerPressed { position: LogicalPosition::new(400.0, 300.0), button: PointerEventButton::Middle });
instance.window().dispatch_event(WindowEvent::PointerMoved { position: LogicalPosition::new(450.0, 350.0) });

// Pan should be updated
assert_eq!(instance.get_test_pan_x(), 50.0);
assert_eq!(instance.get_test_pan_y(), 50.0);

// Mouse exits the window during panning
instance.window().dispatch_event(WindowEvent::PointerExited);

// Pan value should be preserved at last position
assert_eq!(instance.get_test_pan_x(), 50.0);
assert_eq!(instance.get_test_pan_y(), 50.0);

// After mouse re-enters and moves, panning should NOT continue (was cancelled)
instance.window().dispatch_event(WindowEvent::PointerMoved { position: LogicalPosition::new(500.0, 400.0) });
assert_eq!(instance.get_test_pan_x(), 50.0);
assert_eq!(instance.get_test_pan_y(), 50.0);
```

```rust
// Test: Escape key when no interaction is happening (should be ignored gracefully)
use slint::{SharedString, platform::Key};
let instance = TestCase::new().unwrap();

// Initial state - no link creation in progress
assert_eq!(instance.get_test_link_cancelled_count(), 0);

// Press Escape when nothing is happening
slint_testing::send_keyboard_string_sequence(&instance, &SharedString::from(Key::Escape));

// Should not crash, and link-cancelled should NOT be called (no link was being created)
assert_eq!(instance.get_test_link_cancelled_count(), 0);

// Verify other state is unaffected
assert_eq!(instance.get_test_pan_x(), 0.0);
assert_eq!(instance.get_test_pan_y(), 0.0);
assert_eq!(instance.get_test_zoom(), 1.0);
```

```rust
// Test: Selection box properties during Ctrl+drag
use slint::{platform::WindowEvent, platform::PointerEventButton, LogicalPosition, platform::Key};
let instance = TestCase::new().unwrap();

// Initial state
assert_eq!(instance.get_test_is_selecting(), false);
assert_eq!(instance.get_test_selection_changed_count(), 0);

// Hold Ctrl and start selection
slint_testing::send_keyboard_char(&instance, Key::Control.into(), true);
instance.window().dispatch_event(WindowEvent::PointerMoved { position: LogicalPosition::new(100.0, 100.0) });
instance.window().dispatch_event(WindowEvent::PointerPressed { position: LogicalPosition::new(100.0, 100.0), button: PointerEventButton::Left });

// Should now be selecting
assert_eq!(instance.get_test_is_selecting(), true);
assert_eq!(instance.get_test_selection_x(), 100.0);
assert_eq!(instance.get_test_selection_y(), 100.0);
assert_eq!(instance.get_test_selection_width(), 0.0);
assert_eq!(instance.get_test_selection_height(), 0.0);

// Drag to expand selection box
instance.window().dispatch_event(WindowEvent::PointerMoved { position: LogicalPosition::new(300.0, 250.0) });

// Selection box should be updated
assert_eq!(instance.get_test_is_selecting(), true);
assert_eq!(instance.get_test_selection_x(), 100.0);
assert_eq!(instance.get_test_selection_y(), 100.0);
assert_eq!(instance.get_test_selection_width(), 200.0);
assert_eq!(instance.get_test_selection_height(), 150.0);

// Release to complete selection
instance.window().dispatch_event(WindowEvent::PointerReleased { position: LogicalPosition::new(300.0, 250.0), button: PointerEventButton::Left });
slint_testing::send_keyboard_char(&instance, Key::Control.into(), false);

// Selection should be complete
assert_eq!(instance.get_test_is_selecting(), false);
assert_eq!(instance.get_test_selection_changed_count(), 1);
```

```rust
// Test: Selection box handles reverse drag direction
use slint::{platform::WindowEvent, platform::PointerEventButton, LogicalPosition, platform::Key};
let instance = TestCase::new().unwrap();

// Hold Ctrl and start selection from bottom-right
slint_testing::send_keyboard_char(&instance, Key::Control.into(), true);
instance.window().dispatch_event(WindowEvent::PointerPressed { position: LogicalPosition::new(400.0, 300.0), button: PointerEventButton::Left });

// Drag to top-left (reverse direction)
instance.window().dispatch_event(WindowEvent::PointerMoved { position: LogicalPosition::new(100.0, 100.0) });

// Selection box should have correct bounds (min/max calculated)
assert_eq!(instance.get_test_selection_x(), 100.0);  // min x
assert_eq!(instance.get_test_selection_y(), 100.0);  // min y
assert_eq!(instance.get_test_selection_width(), 300.0);  // max_x - min_x
assert_eq!(instance.get_test_selection_height(), 200.0);  // max_y - min_y

// Release
instance.window().dispatch_event(WindowEvent::PointerReleased { position: LogicalPosition::new(100.0, 100.0), button: PointerEventButton::Left });
slint_testing::send_keyboard_char(&instance, Key::Control.into(), false);
```

```rust
// Test: Context menu position is stored
use slint::{platform::WindowEvent, platform::PointerEventButton, LogicalPosition};
let instance = TestCase::new().unwrap();

// Right-click at specific position
instance.window().dispatch_event(WindowEvent::PointerPressed { position: LogicalPosition::new(250.0, 175.0), button: PointerEventButton::Right });

// Context menu position should be stored
assert_eq!(instance.get_test_context_menu_x(), 250.0);
assert_eq!(instance.get_test_context_menu_y(), 175.0);
assert_eq!(instance.get_context_menu_count(), 1);

// Right-click at different position
instance.window().dispatch_event(WindowEvent::PointerReleased { position: LogicalPosition::new(250.0, 175.0), button: PointerEventButton::Right });
instance.window().dispatch_event(WindowEvent::PointerPressed { position: LogicalPosition::new(500.0, 400.0), button: PointerEventButton::Right });

// Position should be updated
assert_eq!(instance.get_test_context_menu_x(), 500.0);
assert_eq!(instance.get_test_context_menu_y(), 400.0);
assert_eq!(instance.get_context_menu_count(), 2);
```

*/
